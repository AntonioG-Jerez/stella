from eu_dirs import *
from numpy import *
from pylab import *
from struct import *
from scipy import polyval, polyfit, interpolate, optimize, std, mean, stats, gradient
from scipy.interpolate import UnivariateSpline,Rbf, griddata, interp2d, interp1d
from scipy.integrate import cumtrapz, simps
from scipy.interpolate import RectBivariateSpline
from scipy.optimize import fsolve
from matplotlib import pylab, mlab, cm
from matplotlib.ticker import MultipleLocator
from matplotlib.ticker import AutoMinorLocator
from matplotlib.ticker import LinearLocator, FixedLocator, FormatStrFormatter
import matplotlib.pyplot as plt
import matplotlib.animation as manimation
import tabCompleter

from matplotlib.ticker import FormatStrFormatter
from mpl_toolkits.mplot3d import axes3d, Axes3D
from mpl_toolkits.axes_grid1 import make_axes_locatable
from plotbox import *
from tabCompleter import *

plt.rcParams.update({'font.size': 28})
plt.rcParams['lines.linewidth'] = 2
import struct
import physcon as pc
import time
import os

def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
        return i + 1

def format(value):
    return "%.3e" % value

def format2(value):
    return "%14.6e" % value
def format3(value):
    return "%4.2f" % value
def format4(value):
    return "%6.2f" % value
def format6(value):
    return "%7.3f" % value
def format5(value):
    return "%.5e" % value
def format7(value):
    return "%22.3f" % value
   
def historias(case):
    inputfile= runsdir() + case + '/input'    
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()

    kin          = content.split("kinspecies=")[1].split("\n")[0]

    if 't,f,f' in kin:
        historias=['history.dat', None, None]
    if 't,t,f' in kin:
        print 'Specify species (kin = t,t,f)'
        historias=['history_i.dat', 'history_e.dat', None]
    if 't,f,t' in kin:
        print 'Specify species (kin = t,f,t)'
        historias=['history_i.dat', None, 'history_f.dat']
    if 'f,t,f' in kin:
        historias=[None, 'history_e.dat', None]
    if 'f,t,t' in kin:
        print 'Specify species (kin = f,t,t)'
        historias=[None, 'history_e.dat', 'history_f.dat']
    if 'f,f,t' in kin:
        historias=[None, None, 'history_f.dat']
    if 't,t,t' in kin:
        print 'Specify species (kin = t,t,t)'
        historias=['history_i.dat', 'history_e.dat', 'history_f.dat']

    return historias
    
        
def history(case, species=-1):
    inputfile= runsdir() + case + '/input'
    
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    
    kin          = content.split("kinspecies=")[1].split("\n")[0]

    if 'f,f,t' in kin:
        historia = '/history_f.dat'
    elif 't,f,f' in kin:
        historia = '/history.dat'
    elif 'f,t,f' in kin:
        historia = '/history_e.dat'
    elif 't,f,t' in kin:
        historia = ['/history_i.dat', '/history_e.dat', '/history_f.dat']
    elif 't,t,f' in kin:
        historia = ['/history_i.dat', '/history_e.dat']

    if species != -1:
        return historia[species]
    else:
        return historia


def tsim(case, species=-1):

    hisfile = runsdir()+ case + history(case, species)
    
    hisdata = loadtxt(hisfile, skiprows=4)
    t0,tf = hisdata[0,0], hisdata[shape(hisdata)[0]-2, 0]
    return t0, tf

def diag2d_case(case):
    inputfile= runsdir() + case + '/input'
    
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    
    kin          = content.split("kinspecies=")[1].split("\n")[0]
    nsel_diag_2d = content.split("nsel_diag_2d=")[1].split(",")[0]
    if(nsel_diag_2d != 't'): print 'nsel_diag_2d not .TRUE.' ; exit

    if 'f,f,t' in kin:
        diag2d_file = '/diag2d_f.dat'
    elif 't,f,f' in kin:
        diag2d_file = '/diag2d.dat'
    elif 'f,t,f' in kin:
        diag2d_file = '/diag2d_e.dat'
    elif 't,f,t' in kin:
        diag2d_file = '/diag2d_i.dat'
    elif 't,t,f' in kin:
        diag2d_file = '/diag2d_i.dat'
    return diag2d_file

def read_history(case, column=-1, species=-1):

    datafile  = runsdir() + case + history(case, species)

    data      = loadtxt(datafile, dtype='float', skiprows=4)

    if column >= 0:
        return data[:,column]
    else:
        return data
    
def read_npars(case):
#
#   Function that reads the file pars.dat and
#   return a vector with the EUTERPE normalization parameters
#
    datafile = runsdir() + case + '/pars.dat'
    myfile       = open(datafile)
    content      = myfile.read()
    myfile.close()

    tstar    = content.split("T* [keV]")[1].split("\n")[0].split("=")[1]
    nstar    = content.split("n* [e19m-3]")[1].split("\n")[0].split("=")[1]
    rstar    = content.split("r* [m]")[1].split("\n")[0].split("=")[1]
    vstar    = content.split("v* [m s-1]")[1].split("\n")[0].split("=")[1]
    bstar    = content.split("B* [T]")[1].split("\n")[0].split("=")[1]
    omstar   = content.split("Omega* [Hz]")[1].split("\n")[0].split("=")[1]
    efstar   = content.split("efield* [N/C]")[1].split("\n")[0].split("=")[1]
    bin_c    = content.split("bin centre")[1].split("\n")[0].split("=")[1]
    sfactor  = content.split("int(dS/|grad_psi|)")[1].split("\n")[0].split("=")[1]
    iota     = content.split("iota (s0)")[1].split("\n")[0].split("=")[1]
    nu_i     = content.split("nu_i [Hz,EU]        =  ")[1].split("  ")[0]
    nu_e     = content.split("nu_e [Hz,EU]        =  ")[1].split("  ")[0]
    
    if kin(case)[4] == 't':
        nu_f     = content.split("nu_f [Hz,EU]        =  ")[1].split("  ")[0]
        
        return float(tstar),float(nstar),float(rstar),float(vstar),\
               float(bstar),float(omstar),float(efstar),float(bin_c),\
               float(sfactor),float(iota), float(nu_i), float(nu_e), float(nu_f)

    return float(tstar),float(nstar),float(rstar),float(vstar),\
           float(bstar),float(omstar),float(efstar),float(bin_c),\
           float(sfactor),float(iota), float(nu_i), float(nu_e)

def nus(case):
#
#   Function that reads returns collisionality written in
#   the file pars.dat for the three species.
#
    datafile = runsdir() + case + '/pars.dat'
    myfile       = open(datafile)
    content      = myfile.read()
    myfile.close()

    nu_i_si, nu_i_eu =  map(scifloat, content.split('nu_i' + " [Hz,EU]        =  ")[1].\
                        split("\n")[0].split("  "))
    nu_e_si, nu_e_eu =  map(scifloat, content.split('nu_e' + " [Hz,EU]        =  ")[1].\
                        split("\n")[0].split("  "))

    if kin(case)[4] == 't':
        nu_f_si, nu_f_eu =  map(scifloat, content.split('nu_f' + " [Hz,EU]        =  ")[1].\
                                split("\n")[0].split("  "))
        
        return nu_i_si, nu_i_eu, nu_e_si, nu_e_eu, nu_f_si, nu_f_eu
    
    return nu_i_si, nu_i_eu, nu_e_si, nu_e_eu
    

    
def rmin(case):
    if "aug0" in case:
        a  = 0.6258
        r0 = 1.616
    if "augh0" in case:
        a  = 0.6258
        r0 = 1.616
    if "lhd0" in case:
        a  = 0.597971
        r0 = 3.72824
    elif "lhd2" in case:
        a  = 0.590866
        r0 = 3.65774
    elif "lhd3" in case:
        # Equil from JL for Phi1 estimates.
        a  = 0.614079
        r0 = 3.69131
    elif "lhd6" in case:
        # This is the equilibrium proposed by Satake
        # for benchmarking LHD at different collisional regimes.
        a  = 0.6361
        r0 = 3.673
    elif "w7x1" in case:
        a  = 0.512911
        r0 = 5.51185
    elif "w7x2" in case:
        a  = 0.512911
        r0 = 5.51185
    elif "w7x3" in case:
        a  = 0.512911
        r0 = 5.51185
    elif "w7x4" in case:
        a  = 0.512911
        r0 = 5.51185
    elif "w7xr003" in case:
        a  = 0.5127
        r0 = 5.512
    elif "w7xr006" in case:
        a  = 0.5401
        r0 = 5.51
    elif "w7xr007" in case:
        a  = 0.5409
        r0 = 5.523
    elif "w7xr008" in case:
        a  = 0.5413
        r0 = 5.52347
    elif "w7xr078" in case:
        a  = 0.4967
        r0 = 5.486        
    elif "w7xr11" in case:
        a  = 0.542386
        r0 = 5.54764   
    elif "tok1" in case:
        a  = 0.8
        r0 = 4.0
    elif "tj20" in case:
        a  = 0.192556
        r0 = 1.50406
    elif "lhdih" in case:
        a=0.6177
        r0=3.6998297
    elif "lhdis" in case:
        a=0.636119
        r0=3.67316
    elif "w7xlim" in case:
        a=0.614644
        r0=5.4971
    elif "w7xop11" in case:
        a=0.503092
        r0=5.48918

    return a,r0

def loadsp(case):
#   This function return the value of loadsp used
#   in the input case.
#
    datafile = runsdir() + case + '/input'
    myfile       = open(datafile)
    content      = myfile.read()
    myfile.close()

    loadsp      = int(float(content.split("loadsp=")[1].split(",")[0]))

    return loadsp

def load_s0(case):
#
#   This function return the value of load_s0 used
#   in the input case.
#
    datafile = runsdir() + case + '/input'
    myfile       = open(datafile)
    content      = myfile.read()
    myfile.close()

    loadsp      = int(float(content.split("loadsp=")[1].split(",")[0]))
    if loadsp == 3:
        load_s0     = float(content.split("load_s0=")[1].split(",")[0])
    if loadsp == 1:
        load_s0     = float(content.split("s0_flsurf=")[1].split(",")[0])
    return load_s0

def neo_eang(case):
#
#   This function return the value of load_s0 used
#   in the input case.
#
    datafile = runsdir() + case + '/input'
    myfile       = open(datafile)
    content      = myfile.read()
    myfile.close()

    if 'neo_eang' in content:
        boltzmann       = int(float(content.split("boltzmann=")[1].split(",")[0]))
        neo_eang        = int(float(content.split("neo_eang=")[1].split(",")[0]))
    else:
        neo_eang = 0

    
#    if boltzmann != neo_eang:
#        print 'Warning!!: boltzmann != neo_eang'

    return neo_eang

def kin(case):
#   Function that returns the string present in the input
#   to set up the kinetic species:
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    kin          = content.split("kinspecies=")[1].split("\n")[0]
    return kin

def colwith(case):
#   Function that returns the string present in the input
#   to set up the kinetic species:
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    if "colwith" in content:
        colwith          = content.split("colwith=")[1].split("\n")[0]
        return colwith
    else:
        return 'f,f,f'

def neo_er(case):
#   Function that returns the string present in the input
#   to set up the kinetic species:
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    neo_er       = content.split("neo_er=")[1].split(",")[0]
    return int(neo_er)

def efield_r(case):
#   Function that returns the string present in the input
#   to set up the kinetic species:
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    neo_er       = content.split("efield_r=")[1].split(",")[0]
    return float(neo_er)

def read_input(case):
#   Function that returns the string present in the input
#   to set up the kinetic species:
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    deltat       = content.split("deltat=")[1].split(",")[0]
    nfreq        = content.split("nfreq=")[1].split(",")[0]
    
    return float(deltat), int(nfreq)

def col(case):
#   Function that returns the string present in the input
#   to set up the collisional species:
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    col          = content.split("colspecies=")[1].split("\n")[0]
    return col


def dtsdti(case):
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    dtsdti    = [1.0, 1.0, 1.0]
    
    if 'multidt' in content:
        multidt   = content.split("multidt=")[1].split("\n")[0].split(",")[0]
        dtsdti    = [1.0, 0.02, 1.0]
    if 'dtsdti' in content:
        dtsdti    = content.split("dtsdti=")[1].split("\n")[0].split(",")[0:3]

    return map(scifloat, dtsdti)
    
def profiles(case):
    inputfile= runsdir() + case + '/input'
    
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    
    kin          = content.split("kinspecies=")[1].split("\n")[0]

    if 'f,f,t' in kin:
        perfiles = ['', '', '/profiles_f.dat']
    elif 't,f,f' in kin:
        perfiles = ['/profiles.dat', '', '']
    elif 'f,t,f' in kin:
        perfiles = ['', '/profiles_e.dat', '']
    else:
        perfiles = ['/profiles_i.dat', '/profiles_e.dat', '/profiles_f.dat']
        
    return perfiles


def mfdmp(case):
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    m_f = content.split("NML_FAST")[1].split("msdmp=")[1].split(",")[0]
    return float(m_f)

def qsde(case):
    inputfile= runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    q_f = content.split("NML_FAST")[1].split("qsde=")[1].split(",")[0]
    return float(q_f)

def prof_tanh(kappa=2.0, X0=None, speak=0.5, width=0.05, plot=0):
    # For tanh-like profiles assuming sign(gradX) < 0
    # i.e. kappa is the absolute value of the maximum 
    # X0 can be the density (in m^-3) and T (in eV) at speak
    

    C     =  cosh(speak/width)**(-2.0)    
    s     =  linspace(0,1,1000)
    dlnX  =  -kappa/(1.0 - C)*(cosh((s-speak)/width)**(-2.0)-C)

    lnX   = cumtrapz(dlnX, x=s, initial=0)
    
    X     = exp(lnX)

    if X0 != None:
        Xatspeak = interpol(s, X, speak, der=0)
        scale    = X0/Xatspeak
        X = X*scale


    if plot == 1:
        multif, (ax1, ax2) = subplots(1,2,figsize=(18,12))
        subplots_adjust(left=0.15, bottom=0.2, right=0.90, top=0.9,\
                        wspace=0.35, hspace=0.00)
        ax1 = plxy(x1data=s, y1data=X, \
                   xlabel='s', ylabel='X', xrange=[0,1],\
                   yrange=None,fig_size=(8.5, 7.5), ax=ax1)
        ax2 = plxy(x1data=s, y1data=dlnX, \
                   xlabel='s', ylabel='dlnX/ds', xrange=[0,1],\
                   yrange=None,fig_size=(8.5, 7.5), ax=ax2)    
        show()
        
    return s, X, dlnX

def midpoint(f, a, b, n):
    h = float(b-a)/n
    result = 0
    
    for i in range(n):
        result += f((a + h/2.0) + i*h)
        result *= h
    return result

def magnitude(x):
    return int(math.log10(x))

def equ(case):
    if '/' in case:
        equil = case.split("/")[1].split("_")[0]
    else:
        equil = case.split("_")[0]
    return equil

def profs(case, nzfact=10.0, save=1, kprho=0.0, nsel_old_equil=1):
    # Function that reads and plot the file profiles.def
    #read_npars(case)
    #tstar = norm(case)[4] / 1000. # in keV
    #nstar = norm(case)[6] / 1.e19 # in 10^19

    tstar = norm2(case)[1] * pc.k_B / pc.e / 1000.# in keV
    nstar = norm2(case)[8] / 1.e19# in 10^19
    equil = equ(case)
    
    datafile = runsdir() + case + '/profiles.def'

    epsname =['none', 'none', 'none', 'none']
    if save != 0:
        epsname[0] = 'T_profs.eps'
        epsname[1] = 'dlnTdr_profs.eps'
        epsname[2] = 'n_profs.eps'
        epsname[3] = 'dlnndr_profs.eps'
    
    if kin(case)[4]=='t' or colwith(case)[4]=='t' or qsde(case) > 1.0 :
        
        data    = loadtxt(datafile, dtype='float', usecols=None)
        # This means that in profiles.def we
        # have the FAST specie's profiles.
        s     = data[:,0]
        dtids = data[:,1]/data[:,2];   ti = data[:,2]  * tstar
        dteds = data[:,3]/data[:,4];   te = data[:,4]  * tstar
        dtfds = data[:,5]/data[:,6];   tf = data[:,6]  * tstar
        dnids = data[:,7]/data[:,8];   ni = data[:,8]  * nstar
        dneds = data[:,9]/data[:,10];  ne = data[:,10] * nstar
        dnfds = data[:,11]/data[:,12]; nf = data[:,12] * nstar
        
        dsdr   = 2*sqrt(s)/rmin(equil)[0]
        
        tran   = max(ti.max(), te.max(), tf.max())*1.25
        nran   = max(ni.max(), ne.max(), nf.max())*1.25
    
        dtran0 = max(-15, min(nanmin(dtids*dsdr), nanmin(dteds*dsdr), nanmin(dtfds*dsdr)))
        dtranf = min( 15, max(nanmax(dtids*dsdr), nanmax(dteds*dsdr), nanmax(dtfds*dsdr)))
        dtran  = [dtran0*1.25, dtranf*1.25]
        
        dnran0 = max(-15, min(nanmin(dnids*dsdr), nanmin(dneds*dsdr),nanmin(dnfds*dsdr)))
        dnranf = min( 15, max(nanmax(dnids*dsdr), nanmax(dneds*dsdr),nanmax(dnfds*dsdr)))
        dnran  = [dnran0*1.25, dnranf*1.25]

        print dnranf, nanmax(dnfds*dsdr)
        
        mag    = magnitude(ni.max()/nf.max())


        multif1, ((ax1, ax2), (ax3, ax4)) = subplots(2,2,figsize=(16,12))
        subplots_adjust(left=0.1, bottom=0.10, right=0.95, top=0.95,\
                        wspace=0.40, hspace=0.40)
        plx3y(xdata=sqrt(s),  y1data=ti, y2data=te, y3data=tf,\
              xlabel='$r/a$', ylabel='$T_{a}$ [keV]', key1='$T_{i}$', key2='$T_{e}$',\
              key3='$T_{z}$', xrange=[0,1],   yrange=[0,tran],\
              fig_size=(8.5, 7.5), ax=ax1)
        plx3y(xdata=sqrt(s),  y1data=ni, y2data=ne, y3data=nf*10**mag,\
              xlabel='$r/a$', ylabel='$n_{a}$ [m$^{-3}$]', key1='$n_{i}$', key2='$n_{e}$',\
              key3='$n_Z\\times 10^'+str(mag)+'$', xrange=[0,1],   yrange=[0,nran],\
              fig_size=(8.5, 7.5), ax=ax2)
        plx3y(xdata=sqrt(s),  y1data=dtids*dsdr, y2data=dteds*dsdr, y3data=dtfds*dsdr,\
              xlabel='$r/a$', ylabel='$\\mathrm{d}\\ln T_{a}/\\mathrm{d}r$',\
              key1='$\\mathrm{d}\\ln T_{i}/\\mathrm{d}r$',\
              key2='$\\mathrm{d}\\ln T_{e}/\\mathrm{d}r$',\
              key3='$\\mathrm{d}\\ln T_{z}/\\mathrm{d}r$',\
              xrange=[0,1],   yrange=dtran,\
              fig_size=(8.5, 7.5), ax=ax3)
        plx3y(xdata=sqrt(s),  y1data=dnids*dsdr, y2data=dneds*dsdr, y3data=dnfds*dsdr,\
              xlabel='$r/a$', ylabel='$\\mathrm{d}\\ln n_{a}/\\mathrm{d}r$',\
              key1='$\\mathrm{d}\\ln n_{i}/\\mathrm{d}r$',\
              key2='$\\mathrm{d}\\ln n_{e}/\\mathrm{d}r$',\
              key3='$\\mathrm{d}\\ln n_{z}/\\mathrm{d}r$',\
              xrange=[0,1],   yrange=dnran,\
              fig_size=(8.5, 7.5), ax=ax4)
        plt.show()


    else:
        data    = loadtxt(datafile, dtype='float', usecols=None)
        s       = data[:,0]
        dtids   = data[:,1]; ti      = data[:,2] ; ti_si = ti*tstar
        dteds   = data[:,3]; te      = data[:,4] ; te_si = te*tstar
        dnids   = data[:,5]; ni      = data[:,6] ; ni_si = ni*nstar
        dneds   = data[:,7]; ne      = data[:,8] ; ne_si = ne*nstar
            
        fig03(sqrt(s), ti_si, te_si, xlabel='$r/a$', ylabel='$T_s$ [keV]',\
              key1='$T_i$', key2='$T_e$', epsname=epsname[0])
        fig03(sqrt(s), dtids/ti, dteds/te, xlabel='$r/a$',\
              ylabel='$\\mathrm{d}\\ln T_{s}/\\mathrm{d}s$',\
              key1='$\\mathrm{d}\\ln T_{i}/\\mathrm{d}s$',\
              key2='$\\mathrm{d}\\ln T_{e}/\\mathrm{d}s$', epsname=epsname[1])
        fig03(sqrt(s), ni_si, ne_si, xlabel='$r/a$',\
              ylabel='$n_s [10^{19} m^{-3}]$',\
              key1='$n_i$', key2='$n_e$', epsname=epsname[2]) 
        fig03(sqrt(s), dnids/ni, dneds/ne, xlabel='$r/a$',\
              ylabel='$\\mathrm{d}\\ln n_{s}/\\mathrm{d}s$',\
              key1='$\\mathrm{d}\\ln n_{i}/\\mathrm{d}s$',\
              key2='$\\mathrm{d}\\ln n_{e}/\\mathrm{d}s$', epsname=epsname[3])
        fig03(sqrt(s), dtids/dnids, dteds/dneds, xlabel='$r/a$',\
              ylabel='$\eta_{s}$',\
              key1='$\eta_{i}$',\
              key2='$\eta_{e}$', epsname=epsname[3], yrange=[-30,30])



    if kprho > 0.0:
        # An estimation for m GK microinstability seed value given a k_perp*rho_L
        equil    = case.split("/")[1].split("_")[0]
        gyrofr   = pc.e * read_vmec0000(equil, nsel_old_equil=nsel_old_equil)[10] / pc.m_p / 2 / pi
        vth      = sqrt(2. * ti_si * 1000. * pc.e / pc.m_p)
        m0       = kprho * (2 * pi * sqrt(s) * rmin(case)[0]) * gyrofr / vth
        iota     = 0.925 ### In construction
        n0       = m0 * iota

        print pc.e, read_vmec0000(equil, nsel_old_equil=nsel_old_equil)[10], pc.m_p, pi 
        
        fig03(sqrt(s), m0, n0, xlabel='r/a', key1='m', key2='n', ylabel='m, n')


##def profs(case, nzfact=10.0, save=1, kprho=0.0):

##    tstar    = norm2(case)[1] * pc.k_B / pc.e / 1000.# in keV
##    nstar    = norm2(case)[8] / 1.e19# in 10^19
##    datafile = runsdir() + case + '/profiles.def'

def launch_s0():
    return 0.015625, 0.04687, 0.1093750, 0.1718750, 0.265625, 0.35937, 0.5156250, 0.6406250, 0.796875


def profs_wrt(equil='none', nefile='none', tefile='none', \
              nifile='none', tifile='none', ne=1, te=2,\
              fsl='rho', ni=3, ti=4, s_norm=0.5, z=1.0, zprof=None, kappanz=0.0,\
              nz0=1.0E12, speak=0.015625, width=0.001, zeff=1.0, rcol=0, tunit=1000,
              nunit=1e19, nsel_old_equil=0, tj20='none', ti0=0.0, z_wrt=1):
    #
    # This functions writes out in a readable formar for EUTERPE 
    # a file with the T and n profiles (and norm. gradients) given
    # an input profiles.
    #
    # Assuming [te]=keV and [nx]=10^{20} m^{-3}
    #


#    lowBR       = read_vmec0000(equil, nsel_old_equil)[0]
#    highBR      = read_vmec0000(equil, nsel_old_equil)[1]
#    b0          = read_vmec0000(equil, nsel_old_equil)[10]
    lowBR, highBR, b0 = 4.50, 6.50, 2.35
    deltax      = highBR - lowBR

    data_ne    = loadtxt(nefile, dtype='float')
    data_te    = loadtxt(tefile, dtype='float')
    data_ni    = loadtxt(nifile, dtype='float')

    
    if(tj20 == 'ech'):
        data_ti    = loadtxt(nefile, dtype='float')
        ti=ne
        data_ti[:, ti]  = data_ti[:, ti]*ti0/data_ti[0,ti]
    elif(tj20 == 'nbi'):
        data_ti  = data_te
        ti = te
        data_ti[:, ti]  = data_te[:,te]*ti0/data_te[0,te]
    else:
        data_ti    = loadtxt(tifile, dtype='float')
            
    # s = rho**2
    s = np.linspace(0,1.,1000)
        
        
    if fsl == 'rho':
        # Flux surface label is rho = r/a
        tck_ne       = interpolate.splrep(data_ne[:,rcol]**2.,data_ne[:,ne],s=0)
        tck_te       = interpolate.splrep(data_te[:,rcol]**2.,data_te[:,te],s=0)
        tck_ni       = interpolate.splrep(data_ni[:,rcol]**2.,data_ni[:,ni],s=0)
        tck_ti       = interpolate.splrep(data_ti[:,rcol]**2.,data_ti[:,ti],s=0)  
    elif fsl == 's':
        # Flux surface label is rho**2
        tck_ne       = interpolate.splrep(data_ne[:,rcol],data_ne[:,ne],s=0)
        tck_te       = interpolate.splrep(data_te[:,rcol],data_te[:,te],s=0)
        tck_ni       = interpolate.splrep(data_ni[:,rcol],data_ni[:,ni],s=0)
        tck_ti       = interpolate.splrep(data_ti[:,rcol],data_ti[:,ti],s=0)        
    elif fsl == 'reff':
        # Flux surface label is r
        amin = rmin(equil)[0]
        tck_ne       = interpolate.splrep((data_ne[:,rcol]/amin)**2,data_ne[:,ne],s=0)
        tck_te       = interpolate.splrep((data_te[:,rcol]/amin)**2,data_te[:,te],s=0)
        tck_ni       = interpolate.splrep((data_ni[:,rcol]/amin)**2,data_ni[:,ni],s=0)
        tck_ti       = interpolate.splrep((data_ti[:,rcol]/amin)**2,data_ti[:,ti],s=0)

    ne      = interpolate.splev(s,tck_ne,der=0)
    te      = interpolate.splev(s,tck_te,der=0)
    ni      = interpolate.splev(s,tck_ni,der=0)
    ti      = interpolate.splev(s,tck_ti,der=0)

    dne     = interpolate.splev(s,tck_ne,der=1); dne = dne/ne
    dte     = interpolate.splev(s,tck_te,der=1); dte = dte/te
    dni     = interpolate.splev(s,tck_ni,der=1); dni = dni/ni
    dti     = interpolate.splev(s,tck_ti,der=1); dti = dti/ti

    
    if size(tifile) == 4:
        print 'Assuming profile_type = 2'
        ti  = tifile[0]*(1.-tifile[1]*s**tifile[2])**tifile[3]
        dti = -tifile[1]*tifile[2]*tifile[3]*s**(tifile[2]-1)/\
              (1.-tifile[1]*s**tifile[2])
        
    ne      = ne * nunit
    ni      = ni * nunit
    te      = te * tunit
    ti      = ti * tunit * 3.5

    # If we introduce an impurity
    # We assume Tz = Ti
    if((z > 1.0) and (zeff > 1.0)):
        nz      = ((zeff-1.)/(z*(z-1.))) * ne
        ni      = ne * (z - zeff)/(z - 1.0)
        dnz     = dne
        tz      = ti
        dtz     = dti

    if zprof=='tanh':
        tz      = ti
        dtz     = dti
        sdump, nz, dnz = prof_tanh(kappa=kappanz, X0=nz0, speak=speak, width=width, plot=1)

    # Getting lx for simulation
        
    s_dim       = size(s)        
    s_step      = (s[s_dim-1] - s[0]) / float(s_dim - 1)
    s_norm_pos  = int((s_norm-s[0])/s_step)
    t_star      = te[s_norm_pos]


    lx          = sqrt((pc.e * b0 * deltax)**2. / pc.m_p/ t_star / pc.e)
    te0         = te[s_norm_pos]
    tsite0      = float(ti[s_norm_pos]/te0)

    out_file  = './prof_4_euterpe.dat'
    f           = open(out_file,'w')
    for i in range(0,1000):
        f.write(str(format2(s[i])))
        
        f.write(str(format2(dti[i])))
        f.write(str(format2(ti[i])))
        f.write(str(format2(dte[i])))
        f.write(str(format2(te[i])))
        
        if (((z > 1.0) and (zeff > 1.0) and z_wrt == 1) or zprof != None):
            f.write(str(format2(dti[i])))
            f.write(str(format2(ti[i])))
            
        f.write(str(format2(dni[i])))
        f.write(str(format2(ni[i])))
        f.write(str(format2(dne[i])))
        f.write(str(format2(ne[i])))
        
        if (((z > 1.0) and (zeff > 1.0) and z_wrt == 1) or zprof != None):
            f.write(str(format2(dnz[i])))
            f.write(str(format2(nz[i])))
            
        f.write('\n')

    print 'lx     = ', float(lx)
    print 'tsdte0 = ', tsite0












def nu_name(case):

    inputfile= runsdir() + case + '/input'
    
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()

    col          = content.split("colspecies=")[1].split("\n")[0]
    print 'estamos2', col
    if 'f,f,t' in col:
        nu = 'nu_f'
    elif 't,f,f' in col:
        nu = 'nu_i'
    elif 'f,t,f' in col:
        nu = 'nu_e'        
        
    return nu


def rb_value(data,fmt='2i'):
#  
#   This function return the data storaged in a line of a binary data.
#
#   Input
#   
#   data = block of binary data
#   fmt  = format of the line to be read, e.g. 2d (two double precsission)
#
#   It assumes that the line begins and ends with an integer. The output
#   is then the data contained in between this two integers.
#
    var_fmt  = fmt
    var_size = calcsize(var_fmt)

    var_value= struct.unpack('>' + var_fmt, data.read(var_size))
    if(len(var_value)==1):
        var_value = var_value[0]
    else:
        var_value = var_value[0:len(var_value)]
    
    return var_value

def read_vmec0000(equil_case, nsel_old_equil=1):
#    
#   This function reads the first 12 quantities
#   storaged in the filed vmec.0000 for later used
#   in other functions, e.g. lx_t0. As a guidiline
#   we have looked at how EUTERPE reads it according to
#   the following lines.
#
#   READ (UNIT=LUDUMP) edge_rmin, edge_rmax, edge_zmin, edge_zmax
#   READ (UNIT=LUDUMP) nfp, nequ_r, nequ_z, nphi_map
#   READ (UNIT=LUDUMP) ns_map, nchi_map
#   READ (UNIT=LUDUMP) bges0, volume

    bin         = open(equilsdir() + equil_case +\
                       '/vmec.equ.0000', 'rb')
    rb_value(bin,'1i')

##   If new mapping program is used.

    if nsel_old_equil == 0:
        version = rb_value(bin,'1d') ; rb_value(bin)
        nbuf    = rb_value(bin,'1i') ; rb_value(bin)
        
    edge_rmin = rb_value(bin,'1d')
    edge_rmax = rb_value(bin,'1d')
    edge_zmin = rb_value(bin,'1d')
    edge_zmax = rb_value(bin,'1d')
    rb_value(bin)
    nfp       = rb_value(bin,'1i')
    nequ_r    = rb_value(bin,'1i')
    nequ_z    = rb_value(bin,'1i')
    nphi_map  = rb_value(bin,'1i')
    rb_value(bin)
    ns_map    = rb_value(bin,'1i')
    nchi_map  = rb_value(bin,'1i')
    rb_value(bin)
    bges0     = rb_value(bin,'1d')
    volume   = rb_value(bin,'1d')

    print version
    
    return float(edge_rmin), float(edge_rmax), float(edge_zmin), float(edge_zmax), \
           int(nfp), int(nequ_r), int(nequ_z), int(nphi_map),\
           int(ns_map), int(nchi_map),\
           float(bges0), float(volume)





##    if mod == 'c':
##        myfile       = open(parsfile)
##        content      = myfile.read()
##        myfile.close()

##        nu_th        = content.split(nu_name(case) + " [Hz,eu]        =")[1].\
##                       split("  ")[2].split("\n")[0]
###        nu_th        = content.split(nu_name(case) + " [eu]")[1].\
###                       split("\n")[0].split("=")[1]
##        tau_th       = 1./float(nu_th)
##        timeini      = timeini * tau_th
##        timeend      = timeend * tau_th
    
###   Estimation of the initial row to be read for fit
##    lineini    = int(float(timeini)/float(nfreq)/float(deltat))
##    lineend    = int(float(timeend)/float(nfreq)/float(deltat))

##    if lineini == 0: 
##        print 'Error 01: lineini = 0, initial time may be too low.'
##        raise SystemExit
    
###   Reading time and efield columns in history.dat file
##    data    = loadtxt(datafile, dtype='float', skiprows=4+lineini, usecols=(0,10))
    
##    time    = data[:,0]
##    pflux   = data[:,1]

##    if lineend > lineini:
###       Removing footer if timeend is specified and larger than timeini
###       Array with the positions of the elements to be removed from footer
###       of time and pflux arrays.
##        footer = arange(lineend-lineini, len(time), 1)
##        time   = delete(time,footer)
##        pflux  = delete(pflux,footer)
        
##    n       = len(time)
    
###   Linear regression estimation
##    avrg_pflux = mean(pflux)
##    err_pflux  = std(pflux)

###   Conversion to SI units
##    nstar    = read_npars(case)[1]
##    rstar    = read_npars(case)[2]
##    vstar    = read_npars(case)[3]
##    omstar   = read_npars(case)[5]
##    sfactor  = read_npars(case)[8]
##    a        = rmin(case)[0]
##    r0       = rmin(case)[1]

##    norm_flux       = vstar*nstar*(rstar**2.)*sfactor*1.e19
##    norm_flux_dens  = nstar*1.e19*vstar*(1./rstar)*(a/2./sqrt(load_s0(case)))

##    avrg_pflux_si = avrg_pflux * norm_flux
##    err_pflux_si  = err_pflux  * norm_flux
##    avrg_pflux_dens_si = avrg_pflux * norm_flux_dens
##    err_pflux_dens_si  = err_pflux  * norm_flux_dens

###    print 'ratio    ', avrg_pflux_si/avrg_pflux_dens_si
###    print 'Area cyl ', 4*pi*pi*a*sqrt(load_s0(case))*r0 
###    print 'Area eut ', 2.*sqrt(load_s0(case))*sfactor*(rstar**3.)/a
            
##    if flagplot == 1:

##        pflux_si = pflux * norm_flux
##        figure1 = figure(num=None, figsize=(7.0,7.0), dpi=100)
##        subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
##                        wspace=0.00, hspace=0.00)
##        plot1          = plt.subplot(1,1,1)
##        plot1.set_xlabel('$t$ [$\Omega_{*}^{-1}$]')
##        plot1.set_ylabel('$F_{i}$ [$10^{17}$ parts s$^{-1}$]')
##        gca = plot1.plot(time,pflux_si,'k-')
##        plot1.grid(color='grey', linestyle='-', linewidth=0.3)
##        major_formatter = pylab.FormatStrFormatter('%.0e')
##        pylab.gca().xaxis.set_major_formatter(major_formatter)
##        show()
        
##    return float(format(avrg_pflux_si)), float(format(err_pflux_si)),\
##           float(format(avrg_pflux_dens_si)), float(format(err_pflux_dens_si))



def fluxes(case, t0=0.0, tf=0.0, species=0, si=0, colavrg=0):
    #
    # Function that gives time averaged fluxes:
    #
    # Particle flux density
    # Energy flux density
    # Parallel current
    #
    # Read from the history_*.dat files for the
    #
    # ions                  (species=0)
    # electrons             (species=1)
    # impurities (or fast)  (species=2)
    #
    # In the interval [t0,tf]
    #

    # Columns of history_*.dat files
    SIMTIME, NUM0, NUM1, EKIN0, EKIN1, PCURR0, PCURR1,\
    EFLUX0, EFLUX1, PFLUX0, PFLUX1,\
    EFIELDDIAG, EKININT, ENTRDIAG, SUM1, SUM2 = arange(0,16)
    
    # Getting some necessary parameters for the species of interest
    deltat, nfreq = [read_input(case)[0], read_input(case)[1]]
    nu_eu         = nus(case)[species*2 + 1]
    nu_si         = nus(case)[species*2]
    dt_hist       = deltat * nfreq * dtsdti(case)[species]

    # Reading data file and relevant columns
    datafile  = runsdir() + case + '/'+ historias(case)[species]
    data      = loadtxt(datafile, dtype='float', skiprows=4)
    
    time      = data[:,SIMTIME]
    pflux1    = data[:,PFLUX1]
    eflux1    = data[:,EFLUX1]
    pcurr1    = data[:,PCURR1]

    if si == 0:

        if tf  == 0.0: tf = time[size(time)-1]
        if t0  == 0.0: t0 = time[0]
        pos_t0  = int( t0 / dt_hist )
        pos_tf  = int( tf / dt_hist )
        print pos_t0, pos_tf
        labels  = fluxes_labels(species, 0)

        # ncols = Number of collisional times simulated entirely or partially.
        # dpos  = number of timesteps performed per collisional time.
        ncols   = int(time[size(time)-1] * nu_eu) + 1
        dpos    = int(1/nu_eu/dt_hist)

        print '\nSimulation time [EU]    = ', '[', time[0],', ', time[size(time)-1], ']'
        print 'dt in history file [EU] = ', dt_hist
        print 'Simulated col. times    = ', ncols, '\n'
        
    # Conversion into SI units
    if si == 1:
        time    = time    * nu_si / norm(case)[2]
        pflux1  = pflux1  * norm(case)[13]
        eflux1  = eflux1  * norm(case)[16]
        pcurr1  = pcurr1  * norm(case)[17]

        dt_hist = dt_hist * nu_si / norm(case)[2]

        if tf  == 0.0: tf = time[size(time)-1]
        if t0  == 0.0: t0 = time[0]
        if t0 > tf:
            print '\nError: t0 cannot be larger than tf.\n'
            return None
        pos_t0  = int( t0 / dt_hist )
        pos_tf  = int( tf / dt_hist )

        labels  = fluxes_labels(species, 1)

        ncols   = int(time[size(time)-1]) + 1
        dpos    = int(1/dt_hist)

        print '\nSimulation time    [tau_c] = ', '[', time[0],', ', time[size(time)-1], ']'
        print 'dt in history file [tau_c] = ', dt_hist
        print 'Simulated col. times       = ', ncols, '\n'

    # Calculating the mean and standard deviation in the time interval
    mpflux1 = mean(pflux1[pos_t0:pos_tf + 1])
    meflux1 = mean(eflux1[pos_t0:pos_tf + 1])
    mpcurr1 = mean(pcurr1[pos_t0:pos_tf + 1])
    
    epflux1 = std(pflux1[pos_t0:pos_tf + 1])
    eeflux1 = std(eflux1[pos_t0:pos_tf + 1])
    epcurr1 = std(pcurr1[pos_t0:pos_tf + 1])
        
    # Vector with mean and error at each collisional time
    if colavrg == 1:
        time_avrg    = zeros(ncols)
        pflux1_avrg  = zeros(ncols)
        eflux1_avrg  = zeros(ncols)
        pcurr1_avrg  = zeros(ncols)
        epflux1_avrg = zeros(ncols)
        eeflux1_avrg = zeros(ncols)
        epcurr1_avrg = zeros(ncols)        
        pos0         = 0

        for i in range(0,ncols):
            posf            = min((i + 1) * dpos, size(time)-1)
            if si == 1:
                time_avrg[i]    = (i + 1)
            elif si == 0:
                time_avrg[i]    = time[posf]
            pflux1_avrg[i]  = mean(pflux1[pos0:posf + 1])
            eflux1_avrg[i]  = mean(eflux1[pos0:posf + 1])
            pcurr1_avrg[i]  = mean(pcurr1[pos0:posf + 1])
            epflux1_avrg[i] = std(pflux1[pos0:posf + 1])
            eeflux1_avrg[i] = std(eflux1[pos0:posf + 1])
            epcurr1_avrg[i] = std(pcurr1[pos0:posf + 1])
            pos0           = posf + 1

        # Calling plotting functions
        fig02(time_avrg, pflux1_avrg, labels[0], labels[1],\
              bar=[t0,tf], mean = mpflux1, error=epflux1_avrg, num=0)
        fig02(time_avrg, eflux1_avrg, labels[0], labels[2],\
              bar=[t0,tf], mean = meflux1, error=eeflux1_avrg, num=1)
        fig02(time_avrg, pcurr1_avrg, labels[0], labels[3],\
              bar=[t0,tf], mean = mpcurr1, error=epcurr1_avrg, num=2)
    else:        
        # Calling plotting functions
        yrange_pf = [pflux1[0:pos_tf].min(), pflux1[0:pos_tf].max()]
        yrange_ef = [eflux1[0:pos_tf].min(), eflux1[0:pos_tf].max()]
        yrange_pc = [pcurr1[0:pos_tf].min(), pcurr1[0:pos_tf].max()]
        #
        fig01(time, pflux1, labels[0], labels[1], bar=[t0,tf], mean = mpflux1, yrange=yrange_pf, num=0)
        fig01(time, eflux1, labels[0], labels[2], bar=[t0,tf], mean = meflux1, yrange=yrange_ef, num=1)
        fig01(time, pcurr1, labels[0], labels[3], bar=[t0,tf], mean = mpcurr1, yrange=yrange_pc, num=2)
    
    # Returning mean values and standard deviations
    return map(scifloat, [mpflux1, epflux1, meflux1, eeflux1, mpcurr1, epcurr1])


def pflux(case, t0=0.0, tf=0.0, tcut=0.0, species=0, si=0, colavrg=0, fft=0,\
          plot=1, msg=1):
    #
    # Function that gives time averaged particle fluxes only
    #
    # Particle flux density related to f0     : pflux0
    # Particle flux density related to deltaf : pflux1
    #
    # Read from the history_*.dat files for the
    #
    # ions                  (species=0)
    # electrons             (species=1)
    # impurities (or fast)  (species=2)
    #
    # In the interval [t0,tf]
    #

    # Columns of history_*.dat files
    SIMTIME, NUM0, NUM1, EKIN0, EKIN1, EKINDOT0, EKINDOT1,\
    EFLUX0, EFLUX1, PFLUX0, PFLUX1, PCURR0, PCURR1,\
    EFIELDDIAG, EKININT, ENTRDIAG, SUM1, SUM2 = arange(0,18)

    
    # Getting some necessary parameters for the species of interest
    deltat, nfreq = [read_input(case)[0], read_input(case)[1]]
    nu_eu         = nus(case)[species*2 + 1]
    nu_si         = nus(case)[species*2]
    dt_hist       = deltat * nfreq * dtsdti(case)[species]

    # Reading data file and relevant columns
    if species==-1: species=0
    datafile  = runsdir() + case + '/'+ historias(case)[species]
    data      = loadtxt(datafile, dtype='float', skiprows=4)
    
    time      = data[:,SIMTIME]
    pflux0    = data[:,PFLUX0]
    pflux1    = data[:,PFLUX1]

    if si == 0:
        if tcut > 0.0 and tcut < time[size(time)-1]:
            # tcut aims eliminating intervals with explosive behaviour
            pos_tc = int( tcut / dt_hist )
            time    = time[0:pos_tc]
            pflux0  = pflux0[0:pos_tc]
            pflux1  = pflux1[0:pos_tc]            

        if tf  == 0.0: tf = time[size(time)-1]
        if t0  == 0.0: t0 = time[0]
        pos_t0  = int( t0 / dt_hist )
        pos_tf  = int( tf / dt_hist )
            
        labels  = fluxes_labels(species, 0)

        # ncols = Number of collisional times simulated entirely or partially.
        # dpos  = number of timesteps performed per collisional time.
        ncols   = int(time[size(time)-1] * nu_eu) + 1
        dpos    = int(1/nu_eu/dt_hist)

        if msg == 1:
            print '\nSimulation time [EU]    = ', '[', time[0],', ', time[size(time)-1], ']'
            print 'dt in history file [EU]   = ', dt_hist
            print 'Simulated col. times      = ', ncols, '\n'

    # Conversion into SI units
    if si == 1:
        time    = time    * nu_si / norm(case)[2]
        time_s  = time    / norm(case)[2]
        pflux0  = pflux0  * norm(case)[13]
        pflux1  = pflux1  * norm(case)[13]
        dt_hist = dt_hist * nu_si / norm(case)[2]
        if tcut > 0.0 and tcut < time[size(time)-1]:
            # tcut aims eliminating intervals with explosive behaviour
            pos_tc = int( tcut / dt_hist )
            time    = time[0:pos_tc]
            pflux0  = pflux0[0:pos_tc]
            pflux1  = pflux1[0:pos_tc]
            
        if tf  == 0.0: tf = time[size(time)-1]
        if t0  == 0.0: t0 = time[0]
        if t0 > tf:
            print '\nError: t0 cannot be larger than tf.\n'
            return None
        
        pos_t0  = int( t0 / dt_hist )
        pos_tf  = int( tf / dt_hist )
        
        labels  = fluxes_labels(species, 1)

        ncols   = int(time[size(time)-1]) + 1
        dpos    = int(1/dt_hist)

        if msg == 1:
            print '\nSimulation time    [tau_c] = ', '[', time[0],', ', time[size(time)-1], ']'
            print 'dt in history file [tau_c] = ', dt_hist
            print 'Simulated col. times       = ', ncols, '\n'

    # Calculating the mean and standard deviation in the time interval
    mpflux0 = mean(pflux0[pos_t0:pos_tf + 1])
    mpflux1 = mean(pflux1[pos_t0:pos_tf + 1])
    epflux0 = stats.sem(pflux0[pos_t0:pos_tf + 1])
    epflux1 = stats.sem(pflux1[pos_t0:pos_tf + 1])
    #epflux0 = std(pflux0[pos_t0:pos_tf + 1])
    #epflux1 = std(pflux1[pos_t0:pos_tf + 1])

    # If fft of the flux trace is desired
    if fft==1:
        data_fft(datafile='none', time_in=time_s, signal_in=pflux1, plot=1, \
                 lapse=[0.0,0.0])
    
    # Vector with mean and error at each collisional time
    if colavrg == 1:
        time_avrg    = zeros(ncols)
        pflux0_avrg  = zeros(ncols)
        pflux1_avrg  = zeros(ncols)
        epflux0_avrg = zeros(ncols)
        epflux1_avrg = zeros(ncols)
        pos0         = 0

        for i in range(0,ncols):
            posf            = min((i + 1) * dpos, size(time)-1)
            if si == 1:
                time_avrg[i]    = (i + 1)
            elif si == 0:
                time_avrg[i]    = time[posf]
            pflux0_avrg[i]  = mean(pflux0[pos0:posf + 1])
            pflux1_avrg[i]  = mean(pflux1[pos0:posf + 1])
            epflux0_avrg[i] = std(pflux0[pos0:posf + 1])
            epflux1_avrg[i] = std(pflux1[pos0:posf + 1])
            pos0           = posf + 1

        # Calling plotting functions
        fig02(time_avrg, pflux0_avrg, labels[0], labels[1],\
              bar=[t0,tf], mean = mpflux0, error=epflux0_avrg, num=0)
        fig02(time_avrg, pflux1_avrg, labels[0], labels[1],\
              bar=[t0,tf], mean = mpflux1, error=epflux1_avrg, num=1)
    else:        
        # Calling plotting functions

        if plot == 1:
            
            yran0 = [pflux0[0:pos_tf].min(), pflux0[0:pos_tf].max()]
            yran1 = [pflux1[0:pos_tf].min(), pflux1[0:pos_tf].max()]

            yran  = [min(yran0[0], yran1[0])*1.25, max(yran0[1], yran1[1])*1.25]

            ax = pl2y(xdata=time, y1data=pflux1, y2data=pflux0,\
                      xlabel=labels[0], ylabel=labels[1], key1='$\Gamma_{1}$', key2='$\Gamma_{0}$',\
                      xrange=[0, tf], yrange=yran, fig_size=(8.5, 7.5),\
                      wp=0, ax=None, mkt="o", mkc='red', ls1=1, ls2=-1,\
                      hline2=mpflux0, hline1=mpflux1,\
                      vshadow=[t0,tf], title='')
            subplots_adjust(left=0.2, bottom=0.15, right=0.85, top=0.85,\
                            wspace=0.00, hspace=0.00)

            show()
    
    # Returning mean values and standard deviations
    return map(scifloat, [mpflux0, epflux0, mpflux1, epflux1])


def flux(case, diag='p', t0=0.0, tf=0.0, tcut=0.0, species=0, si=0, colavrg=0, fft=0):
    #
    # Function that gives time averaged fluxes only
    #
    # diag='p' Particle flux density related to f0 and f1 : pflux0 and pflux1
    # diag='e' Energy flux density related to f0 and f1 : pflux0 and pflux1
    # diag='c' Parallel current
    #
    # Read from the history_*.dat files for the
    #
    # ions                  (species=0)
    # electrons             (species=1)
    # impurities (or fast)  (species=2)
    #
    # In the interval [t0,tf]
    #

    # Columns of history_*.dat files
    SIMTIME, NUM0, NUM1, EKIN0, EKIN1, EKINDOT0, EKINDOT1,\
    EFLUX0, EFLUX1, PFLUX0, PFLUX1, PCURR0, PCURR1,\
    EFIELDDIAG, EKININT, ENTRDIAG, SUM1, SUM2 = arange(0,18)

    # Reading data file and relevant columns
    datafile  = runsdir() + case + '/'+ historias(case)[species]
    data      = loadtxt(datafile, dtype='float', skiprows=4)

    time      = data[:,SIMTIME]
    if diag == 'p':
        flux0    = data[:,PFLUX0]
        flux1    = data[:,PFLUX1]
    elif diag == 'e':
        flux0    = data[:,EFLUX0]
        flux1    = data[:,EFLUX1]
    elif diag == 'c':
        flux0    = data[:,PCURR0]
        flux1    = data[:,PCURR1]        
    
def fluxes_labels(species=0, si = 1):
    
    if species == 0: sp = 'i'
    if species == 1: sp = 'e'
    if species == 2: sp = 'Z'
    
    if si == 0:
        lab_0 = '$t [\Omega_{*}^{-1}]$'
        lab_1 = '$\left<\Gamma_{'+sp +'}\cdot\\nabla r\\right>\ [n_{*}v_{*}r_{*}^{-1}a/(2s^{1/2})]$'
        lab_2 = '$\left<\\mathbf{q}_{'+sp +'}\cdot\\nabla r\\right>\ [m_{p}*n_{*}v_{*}^{3}r_{*}^{-1}a/(2s^{1/2})]$'
        lab_3 = '$\left<\\mathbf{J}_{'+sp +'}\cdot\\mathbf{B}\\right>\ [e*n_{*}v_{*}B_{*}]$'
    else:
        lab_0 = '$t [\\tau_'+sp+']$'
        lab_1 = '$\left<\Gamma_{'+sp +'}\cdot\\nabla r\\right>\ [m^{-2}s^{-1}]$'
        lab_2 = '$\left<\\mathbf{q}_{'+sp+'}\cdot\\nabla r\\right>\ [W m^{-2}]$'
        lab_3 = '$\left<\\mathbf{J}_{'+sp+'}\cdot\\mathbf{B}\\right>\ [A\ T\  m^{-2}]$'
        
    return lab_0, lab_1, lab_2, lab_3


def pfluxt(case, nthtau = 0, timeini = 100., flagplot=1):
    
# ==============================================================
# Function for the estimation of the particle flux
# along the time trace evaluated in time intervals
# with the length of thermal collisional times
#
# Input:
#          case    : name of case to be studied (e.g. tok0_004).
# 
#          plot    : FALSE or TRUE (default) if the plot with 
#                    data and fit line are required.
#
# ==============================================================

    from euterpe import pflux
    
    datafile = runsdir() + case + history(case)
    inputfile= runsdir() + case + '/input'
    parsfile = runsdir() + case + '/pars.dat'
    out_data  = 'pflux_tauth.dat'
    
#   Reading deltat in input file 
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    deltat       = content.split("deltat=")[1].split(",")[0]
    nfreq        = content.split("nfreq=")[1].split(",")[0]

    myfile       = open(parsfile)
    content      = myfile.read()
    myfile.close()

    nu_th        = content.split(nu_name(case) + " [Hz,eu]        =")[1].\
                   split("  ")[2].split("\n")[0]
    tau_th       = 1./float(nu_th)
#   Estimation of the initial row to be read for fit
    lineini    = int(float(timeini)/float(nfreq)/float(deltat))
    data    = loadtxt(datafile, dtype='float', skiprows=4+lineini, usecols=(0,10))
    time    = data[:,0]

    n_intervals = int(time[int(size(time))-1]/tau_th)
    if nthtau > n_intervals:
#       number of thermal collisional times considered
        nthtau = n_intervals
    if nthtau == 0:
        nthtau = n_intervals
            
        
        
    matrix      = zeros([nthtau,4])

    f = open(out_data,'w')
    for i in range(0,nthtau):
        timeini = float(i)*tau_th
        timeend = float(i+1)*tau_th
        if i==0:
            timeini = 1000.
        flux = pflux(case,timeini,timeend,0)
#        print f,'\t',flux[0],'\t',flux[1]
        print i, '\t', flux[0], '\t', flux[1],\
              '\t', flux[2], '\t', flux[3]
        matrix[i,0] = i
        matrix[i,1] = timeini
        matrix[i,2] = flux[0] # flux value
        matrix[i,3] = flux[1] # flux value error


    for i in range(0,nthtau):
        for j in range(0,4):
            f.write(str(format(matrix[i,j])))
            f.write('\t')
        f.write('\n')

    #   Plot top left
    figure(num=None, figsize=(11.69,8.27), dpi=100)
    subplots_adjust(left=None, bottom=0.4, right=None, top=None,
                    wspace=0.4, hspace=None)
    
    plot1 = plt.subplot(1,2,1)
    plot1.set_xlabel('time [$\\tau_{\mathrm{th}}$] ')
    plot1.set_ylabel('$\left<\Gamma\cdot\\nabla\psi\\right>$ [$n_{*}v_{*}$]')
    plot1.grid(color='grey', linestyle='-', linewidth=0.3)
    plot1.plot(matrix[:,0],matrix[:,2],\
               'o-',color='red',markersize=5)

    plot1 = plt.subplot(1,2,2)
    plot1.set_xlabel('time [$10^6 \Omega_{*}^{-1}$] ')
    plot1.set_ylabel('$\left<\Gamma\cdot\\nabla\psi\\right>$ [$n_{*}v_{*}$]')
    plot1.grid(color='grey', linestyle='-', linewidth=0.3)
    plot1.plot(matrix[:,1]/1.e6,matrix[:,2],\
               'o-',color='red',markersize=5)
#    plt.legend()
    show()













def nc(case,flagplot=0):

# ======================================================
# Function that reads and output for NC calculations
# the following relevant parameters
#
# s0 : surface where the flux was estimated
# r0 : minor radius of the equilibrium used
# R0 : major radius of equilibrim used
# 
# ======================================================

    import physcon as pc
    import numpy as np
    import matplotlib.pyplot as plt

    eut_in_file = '/net/s01/rjose/RUNS/hpcff2/' + case + '/input'

    if "genius" in case:
        equil=case.split("/")[1].split("_")[0]
    else:
        equil       = case.split("_")[0]

#   Checking if we deal with a tokamak (t), stellarator (s)
#   or slab (c)

    if "tok" in eut_in_file:
        device = 't'
    elif "lhd" in eut_in_file:
        device = 's'
    elif "w7x" in eut_in_file:
        device = 's'
    elif "cyl" in eut_in_file:
        device = 'c'

#   Reading Euterpe input file and relevant parameters       
    eut_in        = open(eut_in_file)
    eut_in_dat    = eut_in.read()
    eut_in.close()

    neocl       = int(eut_in_dat.split("neocl=")[1].split(",")[0])
    load_s0     = float(eut_in_dat.split("load_s0=")[1].split(",")[0])
    load_s0     = float(eut_in_dat.split("load_s0=")[1].split(",")[0])
    lx          = float(eut_in_dat.split("lx=")[1].split(",")[0])
    
#   Reading VMEC input file and relevant parameters

    f           = open('/net/s01/rjose/RUNS/hpcff2/' + case +\
                           '/vmec_equ/input.'+equil, "r")
    vmecinput   = f.read()
    f.close()
    
    f           = open('/net/s01/rjose/RUNS/hpcff2/' + case +\
                           '/vmec_equ/input', "r")
    vmecinput2  = f.read()
    f.close()

    f           = open('/net/s01/rjose/RUNS/hpcff2/' + case +\
                           '/vmec_equ/threed1.'+equil, "r")
    threed1     = f.read()
    f.close()

#   Reading vmec.equ.0000 file to get B0

    bin         = open('/net/s01/rjose/RUNS/hpcff2/' + case +\
                           '/vmec_equ/vmec.equ.0000', 'rb')
    fmt         = '2H4d2H2H4i2H2H2i2H2H2d2H'
    header      = bin.read(calcsize(fmt))
    data        = struct.unpack('>' + fmt, header)
    b0          = data[24]
    bin.close()

    lowBR       = float(vmecinput2.split("lowBR =")[1].split(",")[0])
    highBR      = float(vmecinput2.split("highBR =")[1].split(",")[0])
    
#   Flux surface for NC run and iota value
    s0          = load_s0
    if 'tok' in case:
        
        #   Iota coefs: iota = icoef0 + icoef1*(s^1) + ... + icoef5*(s^5)
        icoef0      = vmecinput.split("AI =")[1].split(",")[0]
        icoef1      = vmecinput.split(icoef0 + ",")[1].split(",")[0]
        icoef2      = vmecinput.split(icoef0 + ",")[1].split(",")[1]
        icoef3      = vmecinput.split(icoef0 + ",")[1].split(",")[2]
        icoef4      = vmecinput.split(icoef0 + ",")[1].split(",")[3]
        icoef5      = vmecinput.split(icoef0 + ",")[1].split(",")[4].split("\n")[0]
        
        iota_s0     = float(icoef0) + float(icoef1)*s0 + \
                      float(icoef2)*(s0**2) + float(icoef3)*(s0**3) + \
                      float(icoef4)*(s0**4) + float(icoef5)*(s0**5)
    else:
        iota_s0     = 0.51
        
    epseff      = 0.10416
#   Minor radius, major radius, and minor radial coordinate
    R0          = float(threed1.split("Major Radius          =")\
                            [1].split("[M]")[0])
    r0          = float(threed1.split("Minor Radius          =")\
                            [1].split("[M]")[0])
    r           = r0 * sqrt(s0)


#   Necessary parameters for radial flux (euterpe)
    kappa_n     = float(eut_in_dat.split("kappan0=")[1].split(",")[0])
    kappa_T     = float(eut_in_dat.split("kappat0=")[1].split(",")[0])
    rs          = (highBR - lowBR) / lx
#   Necessary parameters for radial flux (SI)
    eps         = sqrt(s0) * r0 / R0
    epsh        = 0.0505
    b10         = 0.048
    q           = 1 / iota_s0
    h2avrg      = 1 + eps**2.
    ft          = 1.46*sqrt(eps)
    wci         = 2.*b0/pc.m_p
    nbar        = 1.0

    print rs, lx


#   m_nu    = factor multiplying 1/nu in the 1/nu regime
#    m_nu    = 5. * (2*epseff)**(3./2.) * (kappa_n + 2.*kappa_T) * (2.*sqrt(s0)/r0) * (rs**3.)/\
#              (3. * pi * (R0**2.) * s0)
    m_nu    = 5. * (2*epseff)**(3./2.) * (kappa_n + 2.*kappa_T) * (2.*sqrt(s0)/r0) * (rs**3.)/\
              (3. * pi * (R0**2.))
#   m_b     = slope of Gamma_r in banana regime
    m_b     = ft * nbar *rs  * ( 1. + (eps**2./2.) ) * 2. * sqrt(s0) *\
              (kappa_n + kappa_T) / ( r0 * iota_s0**2. * eps**2. )
#   Gamma_p = value at the plateau regime
    Gamma_p = sqrt(pi/2.)* nbar * rs**2. * (2. * sqrt(s0)/r0) * (kappa_n + 3.*kappa_T/2.)/\
              (R0 * iota_s0 )
#   m_PS    = slope of Gamma_r in PS regime
    m_PS    = 4.* nbar * rs * sqrt(s0) * (kappa_n + kappa_T) / iota_s0**2. / r0
#   cut_bp  = cut between Gamma_r at banana and plateau
    cut_bp  = Gamma_p / m_b
#   cut_pPS = cut between Gamma_r at plateau and PS
    cut_pPS = Gamma_p / m_PS
#   cut_pnu = cut between Plateau and 1/nu regime
    cut_pnu = m_nu/Gamma_p
    print cut_pnu,cut_pPS
#   Defining collisionality domain
    nu_n        = 10
    nu_ini      = 1.e-7
    nu_end      = 1.e-2
    nu_PS       = arange(cut_pPS, nu_end  , (nu_end -cut_pPS)/(nu_n))
    
    if device == 't':
        nu_b        = arange(nu_ini , cut_bp  , (cut_bp -nu_ini) /(nu_n))
        nu_p        = arange(cut_bp , cut_pPS , (cut_pPS-cut_bp) /(nu_n))
        nu          = hstack((nu_b, nu_p, nu_PS))
        
        Gamma_b     = m_b   * nu_b
        Gam_p       = Gamma_p * ones(10)
        Gamma_PS    = m_PS  * nu_PS
        Gamma       = hstack((Gamma_b, Gam_p, Gamma_PS))
    elif device == 's':
        nu_nu       = arange(nu_ini  , cut_pnu , (cut_pnu -nu_ini) /(nu_n))
        nu_p        = arange(cut_pnu , cut_pPS , (cut_pPS-cut_pnu) /(nu_n))
        nu          = hstack((nu_nu  , nu_p, nu_PS))
        Gamma_nu    = m_nu / nu_nu
        Gam_p       = Gamma_p * ones(10)
        Gamma_PS    = m_PS  * nu_PS
        Gamma       = hstack((Gamma_nu, Gam_p, Gamma_PS))

    if "genius" in case:
        case_data=case.split("/")[1]
    else:
        case_data=case
        
    f           = open(case_data + '_pf_neo.dat','w')

    for i in range(0, 3*nu_n):
        f.write(str(nu[i]) + '    ' + str(Gamma[i]) + '\n')

    f.close()
        

    


#   Summary of parameters
    print "\n======================================"
    print "Summary of parameters of run ", case
    print "======================================\n"
    print "s0                          = ", load_s0
    print "iota at s0                  = ", iota_s0
    print "Safety factor at s0         = ", 1/iota_s0
    print "Inv. asp. rat. (eps) at s0  = ", eps
    print "kappa_n                     = ", kappa_n
    print "kappa_T                     = ", kappa_T 
    print "b0                          = ", b0
    print "ft                          = ", ft
    print "R0                          = ", R0
    print "r0                          = ", r0
    print "\n"    

#   Radial particle flux NC parameters
    print "\n======================================"
    print "Gamma_r parameters for associated equ. "
    print "======================================\n"
    print "Gamma_r slope at the 1/nu regime   = ", m_nu
    print "Gamma_r slope at the banana regime = ", m_b
    print "Gamma_r value at the plateau       = ", Gamma_p
    print "Gamma_r value at the PS            = ", m_PS   
    print "\n"
    
    plt.loglog(nu,Gamma,"r",linewidth=3.0)
    plt.grid(True)
    plt.title("$\Gamma_{r}$ for the case " + case, fontsize=18)
    plt.xlabel(r'$\nu [\Omega_{*}]$', fontsize=20)
    plt.ylabel(r'$\Gamma_{r} [n_{*}v_{*}]$', fontsize=20)

    show()
    plt.draw()
    plt.show()

    if flagplot == 1:
        s           = arange(0,1,0.01)
        iota        = float(icoef0) + float(icoef1)*s + \
            float(icoef2)*(s**2) + float(icoef3)*(s**3) + \
            float(icoef4)*(s**4) + float(icoef5)*(s**5)
        plot(s,iota)
        show()


def read_equil(equil):

#=============================================
# Function that read the main parameters from
# the vmec equilibrium introduced, as a
# string
#==============================================


#   Reading input file
    vmec_in     = open('/net/s01/rjose/equilibrios/' + equil +\
                           '/input', "r")
    vmec_in_dat = vmec_in.read()
    vmec_in.close()
    lowBR       = float(vmec_in_dat.split("lowBR =")[1].split(",")[0])
    highBR      = float(vmec_in_dat.split("highBR =")[1].split(",")[0])

#   Reading binary vmec.equ.0000 file for B0
    bin         = open('/net/s01/rjose/equilibrios/' + equil +\
                           '/vmec.equ.0000', 'rb')
    fmt         = '2H4d2H2H4i2H2H2i2H2H2d2H'
    header      = bin.read(calcsize(fmt))
    data        = struct.unpack('>' + fmt, header)
    b0          = data[24]
    bin.close()

    return lowBR, highBR, b0




def pars(case, flagplot=0):


# ======================================================
#
#    Function that extract the values of the
#    parameters of normalization in EUTERPTE, i.e.
#
#    B*, r*, Omega*, v*, T*, n*, Phi*
#
#    As well as other relevant quantities present in
#    the input file for later use.
#
# ======================================================

    import physcon as pc
    import numpy as np
    import matplotlib.pyplot as plt

    
    eut_in_file = '/net/s01/rjose/RUNS/' + case + '/input'


#   Opening files to read
    vmec_in     = open('/net/s01/rjose/RUNS/' + case +\
                           '/vmec_equ/input', "r")
    vmec_in_dat = vmec_in.read()
    vmec_in.close()
    
    eut_in        = open(eut_in_file)
    eut_in_dat    = eut_in.read()
    eut_in.close()

    lowBR       = float(vmec_in_dat.split("lowBR =")[1].split(",")[0])
    highBR      = float(vmec_in_dat.split("highBR =")[1].split(",")[0])
    lx          = float(eut_in_dat.split("lx=")[1].split(",")[0])
    colfreq0    = float(eut_in_dat.split(" colfreq0=")[1].split(",")[0])
    deltax      = (highBR - lowBR)
    rs          = deltax / lx

#   Reading binary vmec.equ.0000 file for B0

    bin         = open('/net/s01/rjose/RUNS/' + case +\
                           '/vmec_equ/vmec.equ.0000', 'rb')
    fmt         = '2H4d2H2H4i2H2H2i2H2H2d2H'
    header      = bin.read(calcsize(fmt))
    data        = struct.unpack('>' + fmt, header)
    b0          = data[24]
    bin.close()
    

    Ts          = ( pc.e * b0 * rs )**2.\
                  / pc.k_B / pc.m_p           # in K
    Tsev        = Ts * pc.k_B / pc.e / 1000.  # in keV

    ws          = pc.e * b0 / pc.m_p          # in rad/s
    fc          = ws / 2. / pi /1.e6          # in GMHz
    vs          = sqrt( pc.k_B * Ts / pc.m_p) # in m/s
    vsc         = vs/ pc.c                    # in units of c
    Phis        = Ts * pc.k_B / pc.e          # in J/C=V
    Apars       = rs * b0                     # in T m

#   The input paramter t0 is the factor that multiplies the
#   electron temperature at the center to get tstar

    print  "lx for t*=t0/2=", sqrt(( pc.e * b0 * deltax)**2. / pc.m_p / (1000. * 1.e-19))

    
#   Summary of parameters
    print "\n============================================="
    print "Normalisation in EUTERPE for case ", case
    print "=============================================\n"
    print "B*        = ", b0," T"
    print "r*        = ", rs," m"
    print "T*        = ", Ts," K     (",Tsev," keV)" 
    print "Omega*    = ", ws," rad/s (",fc,"MHz)"
    print "v*        = ", vs," m/s   (",vsc,"times c)"
    print "Phi*      = ", Phis," V"
    print "A||*      = ", Apars,""
    print "\n"
    

    return deltax,lx,colfreq0,ws,vs,b0,Ts









def coll_ne(case,flagplot=0):


#===========================================================
#
# This function provides for a certain euterpe run the
# density value, n, considering the value of the temperature
# T*, obtained through the parameter of lx
# (remember lx --> r* --> T*), such that colfreq0 in SI units
# is equal to the thermal collisional ei frequency.
#
#===========================================================



    import numpy as np
    import matplotlib.pyplot as plt
    global collfreq0, A, B, cou_b, cou_a, cou_c, c2
    par   =  pars(case)

    collfreq0 =  par[2]
    b0        =  par[5]
    Ts_SI     =  pc.k_B * par[6] # in J
    Ts_eV     =  Ts_SI / pc.e   # in eV

#   Coulog = cou_a + cou_b log10(ne) + cou_c log10 (Te)
    if Ts_eV > 36. :
        cou_a =  73.
    if Ts_eV < 36. :
        cou_a =  70.4
    cou_b = -1.15
    cou_c =  2.3

#   Other constants
    c2    =  (pc.e**(3./2.)) / 3.44e11
    Z     =  1. # by now
    A     =  c2 * pc.m_p * Z / pc.e / b0 / Ts_SI**(1.5)
    B     =  cou_a + cou_c * log10(Ts_SI)

    n0    =  collfreq0 / A / 17.

    n     =  fsolve(f,n0)
    return n/1.e19

def f(x):
    return (collfreq0 - A * ( B + cou_b * log10(x))*x)








def lx_equil(equil, ne, out=0):

#===========================================================
# This function provides for a given  value of the electron
# density (ne), and a VMEC equilibrium the set of
# values of the lx paramter in the EUTERPE input, in order
# to make the colfreq0 match the thermal collision frequency
#
# equil:  string, e.g. 'lhd0'
# ne   :  float, in units of m^{-3} 
#===========================================================


    global collfreq0, c2, A, cou_b, cou_c, ne_SI, colfreq0

#   Other constants
    equil_pars = read_equil(equil)
    low_BR     = equil_pars[0]
    high_BR    = equil_pars[1]
    b0         = equil_pars[2]
    ne_SI      = ne * 1.e19
    c2         =  (pc.e**(3./2.)) / 3.44e11
    Z          = 1. # by now
    cou_b      = -1.15
    cou_c      =  2.3
    A          = c2 * Z * pc.m_p * ne_SI / pc.e / b0    




    nus        = zeros(11)
    T_J        = zeros(11)
    lx         = zeros(11)
    rs         = zeros(11)
    nus[0]     = 3.e-7
    nus[1]     = 1.e-6
    nus[2]     = 3.e-6
    nus[3]     = 1.e-5
    nus[4]     = 3.e-5
    nus[5]     = 1.e-4
    nus[6]     = 3.e-4
    nus[7]     = 1.e-3
    nus[8]     = 3.e-3
    nus[9]     = 1.e-2
    nus[10]    = 3.e-2

    for i in range(0,11):
        colfreq0 = nus[i]
        T0_J     =  1000.*pc.e              # in Jules
        T_J[i]   =  fsolve(g,T0_J)            
        lx[i] =  (high_BR - low_BR) * pc.e * b0 / sqrt( T_J[i] * pc.m_p )
        rs[i] =  (high_BR - low_BR) / lx[i]
        print colfreq0,lx[i]

    if out == 1:
        f   = open('lx_equil_' + equil + '.dat','w')
        f.write('#   Equilibrium      = '+ equil +'\n')
        f.write('#   Electron density = '+ str(ne) + '[10^19 m^{-3}]\n')
        f.write('#   Colfreq0 [Omega*]     lx      rs [m]\n')  
        
        for i in range(0,11):
            f.write('       '+ str(nus[i]) + '             ' + str(lx[i]) +\
                    '       '+ str(rs[i]) + '\n')
            
        f.close()
            
    return nus,lx



def g(x):

#   To avoid that fsolve step out the log function domain    
    if x < 0.:
        x = 1.e-6

#   Coulog = cou_a + cou_b log10(ne) + cou_c log10 (Te)
    if x/pc.e > 36. :
        cou_a =  73.
    if x/pc.e < 36. :
        cou_a =  70.4

    B     = cou_a + cou_c * log10(ne_SI)

    return colfreq0 - A*(B + cou_b * log10(x)) / x**(1.5)
    









    

    











def lamb_ei(Ti,ni,Z=1,mu=1):

#===========================================================
#
# Coulomb logarithm for ion-electron colisions
#
# Ti and Te are ion and electron temperature to be in keV
# mu = mi/mp with mp and mi the proton and ion masses
#
# [ni] = in units of 10^19 m^{-3}
# [Ti] = [Te] = in keV#
# 
#===========================================================

    import physcon as pc

    ni_SI = ni * 10**13         # Converting into SI units (m^{-3})
    ne_SI = ni_SI * Z           # Quasineutrality condition
    Ti_eV  = Ti * 1000.         # Converting into SI units (m^{-3})
    Te_eV  = Ti_eV              # Assuming qual e- and i temperature.
    mi     = pc.m_p * mu

    if Te_eV > 36:    
        lambda_ei    = 32.2 - 1.15*log10(ni * 1e19) + 2.3*log10(Te_eV)
        lambda_ei_SI = 32.2 - 1.15*log10(ni * 1e19) + 2.3*log10(Te_eV*pc.e)+\
                       43.229
    if Te_eV < 36:
        lambda_ei    = 30.4 - 1.15*log10(ni * 1e19) + 3.45*log10(Te_eV)
        lambda_ei_SI = 30.4 - 1.15*log10(ni * 1e19) + 3.45*log10(Te_eV*pc.e)+\
                       43.229

    return lambda_ei,lambda_ei2


def collfreq(Ti,ni,Z=1,mu=1):


#===========================================================
#
# Function that outputs the i-e, e-i and i-i collision
# frequency
#
# Ti and Te are ion and electron temperature to be in keV
# mu = mi/mp with mp and mi the proton and ion masses
#
# [ni] = in units of 10^19 m^{-3}
# [Ti] = [Te] = in keV#
# 
#===========================================================

    import physcon as pc

    Ti_eV   = Ti * 1000.
    Te_eV   = Ti_eV
    ni_SI   = ni * 1.e19
    ne_SI   = Z  * ni_SI
    mi      = mu * pc.m_p
    coulog  = lamb_ei(Ti,ni,Z=1,mu=1)

    tau_ei  = 3.44 * 1.e11 * Te_eV**(3/2) / ne_SI / Z / coulog
    tau_ii  = sqrt(mi / pc.m_e) * Z**2. *tau_ei
    tau_ie  = mi * tau_ei / pc.m_e
              
    return 1/tau_ei, 1/tau_ii, 1/ tau_ie










    
    

def coll_lx(case,flagplot=0):

#===========================================================
#
# This function provides for a certain euterpe case the
# set of collfreq0 values and their corresponding lx ones
#
#===========================================================

    import physcon as pc
    import numpy as np
    import matplotlib.pyplot as plt

    
    eut_in_file = '/net/s01/rjose/RUNS/' + case + '/input'


#   Opening files to read
    vmec_in     = open('/net/s01/rjose/RUNS/' + case +\
                           '/vmec_equ/input', "r")
    vmec_in_dat = vmec_in.read()
    vmec_in.close()
    
    eut_in        = open(eut_in_file)
    eut_in_dat    = eut_in.read()
    eut_in.close()

    lowBR       = float(vmec_in_dat.split("lowBR =")[1].split(",")[0])
    highBR      = float(vmec_in_dat.split("highBR =")[1].split(",")[0])
    lx          = float(eut_in_dat.split("lx=")[1].split(",")[0])
    deltaBR     = (highBR - lowBR)


#   Reading binary vmec.equ.0000 file for B0

    bin         = open('/net/s01/rjose/RUNS/' + case +\
                           '/vmec_equ/vmec.equ.0000', 'rb')
    fmt         = '2H4d2H2H4i2H2H2i2H2H2d2H'
    header      = bin.read(calcsize(fmt))
    data        = struct.unpack('>' + fmt, header)
    b0          = data[24]
    bin.close()

def dlntds(prof_type=0, kappat0=0.2, speak=0.2, widtht0=0.2, s=0.5):
    
    sech20 = cosh(speak / widtht0)**(-2)
    f      = -(kappat0  / (1.0-sech20))  * ((1.0 / cosh((s-speak) / widtht0)**2) -sech20)
    return f

def lx_t0(equil='none', profile_type=2, species='i',\
          t0=1.0, t1=1.0, t2=1.0, t3=1.0,\
          te0=0.0, te1=0.0, te2=0.0, te3=0.0, lx=0.0,\
          tg=0.05, th=-0.5, tw=0.1, s_norm=0.5,
          iprof_fname='none',\
          nsel_old_equil=0):

#=============================================
# Function that calculates the value of lx
# for a wished central value of Te
#
# The profile shape assumed is: t0(1-t1s^t2)^t3
#
# Input parameters: t0,t1,t2
#==============================================

    lowBR       = read_vmec0000(equil, nsel_old_equil)[0]
    highBR      = read_vmec0000(equil, nsel_old_equil)[1]
    b0          = read_vmec0000(equil, nsel_old_equil)[10]
    deltax      = highBR - lowBR

    
    if iprof_fname == 'none' :
            
        
        if profile_type == 2 :
            if species == 'e':
                t_star      = t0 * (1. - t1*s_norm**t2)**t3
                lx          = sqrt((pc.e * b0 * deltax)**2. / pc.m_p / t_star / 1000./ pc.e)
                tsdte0      = 1.0
                
            if species != 'e':
                t_star      = te0 * (1. - te1*s_norm**te2)**te3
                lx          = sqrt((pc.e * b0 * deltax)**2. / pc.m_p / t_star / 1000./ pc.e)

                if t_star == 0.0:
                    t_star  = (pc.e * b0 * deltax)**2. / pc.m_p/ 1000./ pc.e / lx**2.
                    te0     = t_star / ((1. - te1*s_norm**te2)**te3)
                    print 'For the provided lx, Te0 = ', te0 
                if t_star == 0.0:
                    print 'Error: no Te profile specified for tsdte calculation'
                    quit()
                    
                ts_at_norm = t0 * (1. - t1*s_norm**t2)**t3
                tsdte0     = ts_at_norm / t_star

                    
        elif profile_type == 3 :
            t_star      = t0*(tg - th + (1. - tg + th)*(1. - s_norm**t1)**t2 + \
                          th*(1. - exp(-s_norm/tw**2.)))
            lx          = sqrt((pc.e * b0 * deltax)**2. / pc.m_p/ t_star / 1000./ pc.e)
    else:
        data        = loadtxt(iprof_fname, dtype='float', usecols=(0,4))
        s_vec       = data[:,0]
#       Assuming that the Te profile is in eV ...       
        te_vec      = data[:,1]/1000. 
        s_dim       = size(s_vec)        
        s_step      = (s_vec[s_dim-1] - s_vec[0]) / float(s_dim - 1)
        s_norm_pos  = int((s_norm-s_vec[0])/s_step)
        t_star      = te_vec[s_norm_pos]
        lx          = sqrt((pc.e * b0 * deltax)**2. / pc.m_p/ t_star / 1000./ pc.e)
        
    return float(lx), float(tsdte0)


def nz(zi=1,zz=6,zeff=1.05,ne=1.0, iprof_fname='none'):
# Program that provides the value of the ratio between
# the ion and impurity densities, n_zi and n_zz
# for an electron density of ne (default = 1.0)
#
# Input:
#
# zi   : ionization state of ions
# zz   : ionization state of impurities
# zeff : effective charge
#
# In the name of a profile file is specified, the
# columns corresponding 

  if iprof_fname=='none':
      nzz = ne * (zeff - 1.0)/zz/(zz - zi)
      nzi = ne * (zz - zi - zeff + 1.0)/zi/(zz - zi)
      
      return nzi, nzz
  else:
      data        = loadtxt(iprof_fname, dtype='float')
      s           = data[:,0]
      dim         = size(s)
      tst_i       = data[:,1]
      ts_i        = data[:,2]
      tst_e       = data[:,3]
      ts_e        = data[:,4]
      
      nsn_i       = data[:,5]
      ns_i        = data[:,6] * (zz - zi - zeff + 1.0)/zi/(zz - zi)
      
      nsn_e       = data[:,7]
      ns_e        = data[:,8]
      
      ns_f        = ns_e * (zeff - 1.0)/zz/(zz - zi)
      nsn_f       = nsn_e
#     Assumming equat T profile for imps and bulk ions
      ts_f        = ts_i
      tst_f       = tst_i

#     We identify the name of the file containing the profile
      aux         = iprof_fname.split("/")
      profin_name = aux[size(aux)-1]
      profout_name= profin_name.split(".dat")[0] + '_with_nz.dat'
      outdir      = iprof_fname.split(profin_name)[0]
      outfile     = outdir + profout_name

      f           = open(outfile,'w')
      f.write('# Modified profile: ' + iprof_fname + '\n#\n')
      f.write('# Impurity columns added with ')
      f.write('(zi, zz, zeff) = (' + str(zi) + ' ,' + str(zz) + ' ,' + str(zeff) + ')\n#\n')
      for i in range(0,dim):
          f.write(str(format2(s[i])))
          f.write(str(format2(tst_i[i])))
          f.write(str(format2(ts_i[i])))
          f.write(str(format2(tst_e[i])))
          f.write(str(format2(ts_e[i])))
          f.write(str(format2(tst_f[i])))
          f.write(str(format2(ts_f[i])))
          f.write(str(format2(nsn_i[i])))
          f.write(str(format2(ns_i[i])))
          f.write(str(format2(nsn_e[i])))
          f.write(str(format2(ns_e[i])))
          f.write(str(format2(nsn_f[i])))
          f.write(str(format2(ns_f[i]))) ; f.write('\n')
      print '\n New file ' + profout_name + ' created and storareged in:'
      print outdir
      f.close()

def ns(case):
    inputfile = runsdir() + case + '/input'
    myfile       = open(inputfile)
    content      = myfile.read()
    myfile.close()
    nsval = content.split("ns=")[1].split(",")[0]
    return int(nsval)

def sbins(load_s0=0.643, ns=64):
    divs  = linspace(0,1,ns+1)
    ds    = 1./ ns
    mids  = linspace(ds/2, 1-ds/2, ns)

    for i in arange(0, ns):
        if load_s0 >= divs[i] and load_s0 < divs[i+1]:
            print "load_s0    = ", load_s0, " contained in bin ", i, " in range [", divs[i], ", ",divs[i+1],")."
            print "mid_bin_s0 = ", mids[i]
            print "load_s0 - mid_bin_s0 = ", load_s0 - mids[i]

    print mids


def partbins(case,species=0,jump=1):
# Function that read the number of particles per bin
# along the time simulated in a given run.
# The aim is checking the numerical drift of
# the markers.

    datafile = runsdir() + case + profiles(case)[species]

    f = open(datafile,'r')       # Open de file
    n = len(f.readlines())       # Storing the number of lines
    f.close()
    
    f    = open(datafile,'r')    # Open de file
    data = f.read().split('\n')  # Read the data and split data in lines

    nsv   = ns(case)             # Number of radial bins considered for single loading 
    nb    = int(data[4])         # Number of radial bins considered for diag in profiles.dat
    nt    = (n-5)/(nb+1)        # Number of timesteps present in Profiles.dat

    pbins = empty((nt,nb),float) # Matrix, nt: 
    bins  = arange(1,nb+1,1)
    t     = empty(nt, dtype='float')
    
    itime = 0
    ibin  = 0


    for i in range(5,n):
        
        if (len(data[i].split('  ')) == 2):
            t[itime]    = float(data[i].split('  ')[1])
            ibin        = 0
            itime += 1
            
        if (len(data[i].split('  ')) == 12):
            npart             = data[i].split('  ')[11]
            pbins[itime-1,ibin] = npart
            ibin  += 1

                
    ion()
    tstart = time.time()
    
    # plt.axis([0, nb, 0, 1E6])
    fig, ax = plt.subplots(figsize=(11, 8))
    ax.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
#    ax.xlim((0,nb))
    ax.set_ylabel('$N_{m}$')
    ax.set_xlabel('Bin number')
    for i in arange(1,nt,jump):
#        title('t='+str(t[i])+'  $\Omega_{ci}^{-1}$')
        ax.clear()
        ax.bar(bins,pbins[i,:], width=0.99)
        ax.set_title(str(t[i]))
        plt.pause(0.01)
        draw()





def gsrake_read(datafile,n_spl=100,a=1.):
        
# ==============================================================
#
# This function read an output file and postprocess it
# to make it more tractable for EUTERPE. The output has
# the following form.
#
# rho   Er(amb)   Er(amb+qn)   phi1c   phi1s   phi2c   phi2c ...
# ==> nrho X (2*nphi1 + 3) matrix
#
# This postprocessing step is necessary for EUTERPE to read
# the poloidally dependent potental. The output file for euterpe
# is named gsrake_phi1.dat
#
# Remember that the input file is different for a different
# set of ni,ne,ti,te profile. Do you feel me?
#
# ==============================================================

#   Setting initial values to zero
    i_rho     = 0
    n_rho     = 0
    n_fourier = 0

#   Defining input and output data 
    in_data  = './' + datafile
    out_data = './gsrake.dat'
    if 'lhd375' in in_data:
        a = 0.597971

    f           = open(out_data,'w')
    
#   Getting the number of lines in the file
    n_lines  = file_len(in_data)
    

#   Reading and storing the content of the file
    myfile       = open(in_data)
    content      = myfile.read()

#   Preliminary read for determining the number of
#   rho values and and the number of harmonics

    myfile       = open(in_data)
    for l in range(0,n_lines+1):
        line = myfile.readline()
#       Finding and reading rho        
        if 'rho=' in line:
            rho   = line.split("rho=")[1]
            n_rho = n_rho + 1
            
#       Finding and reading nphi1 (number of fourier modes)
        if 'nphi1=' in line:
            n_fourier = int(line.split()[1])
    myfile.close()
    matrix     = zeros([n_rho,n_fourier*2+3])
    matrix_spl = zeros([n_spl,n_fourier*2+3])
    f.write('# Postprocessed output from file: ' + datafile + '\n#\n')
    f.write('# Minor radius, number of fourier modes and reff values' + '\n#\n')
    f.write(str(a)+'\n')
    f.write(str(n_fourier)+'\n')
    f.write(str(n_spl)    +'\n#\n')
    f.write('# psi\t\t E_r_ap \t E_r_ap_qn  \tphi1_C_1\tphi1_S_1 ...\tphi1_C_n\tphi1_S_n\n#\n')
    
    myfile       = open(in_data)
    for l in range(0,n_lines+1):
        line = myfile.readline()
        
#       Finding and reading rho --> we write s        
        if 'rho=' in line:
            rho   = line.split("rho=")[1]
            i_rho = i_rho + 1
            matrix[i_rho-1,0] = float(rho)*a
            
#       Finding value of ambipolar Er
        if 'E_r'   in line:
            e_r = line.split()[2]
            if len(line.split()) == 5:
                e_r_amb    = e_r
                matrix[i_rho-1,1] = e_r_amb
            if len(line.split()) == 3:
                e_r_amb_qn = e_r
                matrix[i_rho-1,2] = e_r_amb_qn
        
#       Finding value of Phi1_C_1, Phi1_S_1, ...
        for i_fourier in range (1,n_fourier + 1): # this means 1 - n_fourier
            phi1c_str = 'Phi1_C_'+ str(i_fourier)
            phi1s_str = 'Phi1_S_'+ str(i_fourier)
            if phi1c_str in line :
                phi1c_val = line.split()[2]
                matrix[i_rho-1,2*(1+i_fourier)-1] = phi1c_val  
            if phi1s_str in line :                
                phi1s_val = line.split()[2]
                matrix[i_rho-1,2*(1+i_fourier)] = phi1s_val
    myfile.close()

    matrix_spl[:,0] = np.linspace(0,1.,n_spl)*a
    for j in range (1,3+n_fourier*2):
        tck             = interpolate.splrep(matrix[:,0],matrix[:,j],s=0)
        matrix_spl[:,j] = interpolate.splev(matrix_spl[:,0],tck, der=0)

    aux_spl         = np.linspace(0,1.,n_spl-1)*a

#   phi = -int_0^r(Er(r')dr')
    phi0_ap         = -cumtrapz(matrix_spl[:,1],(matrix_spl[:,0])) # 99
    phi0_ap_qn      = -cumtrapz(matrix_spl[:,2],(matrix_spl[:,0])) # 99
#   new interpolation to add a component missing in the integral
    tck             = interpolate.splrep(aux_spl,phi0_ap,s=0)
    phi0_ap         = interpolate.splev(matrix_spl[:,0],tck,der=0)
    tck             = interpolate.splrep(aux_spl,phi0_ap_qn,s=0)
    phi0_ap_qn      = interpolate.splev(matrix_spl[:,0],tck,der=0)
#   Generating phi1(r,theta) for plotting
    n_theta         = 100
    theta           = np.linspace(0,2*pi,n_theta)

    phi1 = zeros([n_spl-1,n_theta-1])    

    for i_rho in range (0,n_spl-1):
        for i_theta in range (0,n_theta-1):
            for i_fourier in range (1,n_fourier+1):
                phi1[i_rho, i_theta] = phi1[i_rho, i_theta]+\
                                       matrix_spl[i_rho,i_fourier*2-2+3]*\
                                       cos(i_fourier*theta[i_theta])+\
                                       matrix_spl[i_rho,i_fourier*2-1+3]*\
                                       sin(i_fourier*theta[i_theta])


#    figure(num=None, figsize=(11.69,8.27), dpi=100)
#    subplots_adjust(left=None, bottom=None, right=None, top=None,
#                    wspace=0.7, hspace=0.4)

#   Plot top left
    figure1 = figure(num=None, figsize=(6.0,6.0), dpi=100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot1 = plt.subplot(1,1,1)
    plot1.set_xlabel('$r$ [m]')
    plot1.set_ylabel('$E_{r}$ [V/m]')
    plot1.ticklabel_format(style='plain')
    plot1.grid(color='grey', linestyle='-', linewidth=0.3)
    plot1.plot(matrix[:,0],matrix[:,1],'x',color='red',markersize=5,\
               label='$E_{r}^{\mathrm{ap}}$')
#    plot1.plot(matrix[:,0],matrix[:,2],'x',color='black',markersize=5,\
#               label='$E_{r}^{\mathrm{ap+qn}}$')
#    plot1.plot(matrix_spl[:,0],matrix_spl[:,1],linestyle='dashed',color='red')
    plot1.plot(matrix_spl[:,0],matrix_spl[:,2],color='red',\
               label='$E_{r}$',linewidth=2.5)    
#    plot1.legend(loc=3)
    savefig('er_gsrake_'+ datafile +'.eps')

#   Plot top right
    figure2 = figure(num=None, figsize=(6.0,6.0), dpi=100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot2 = plt.subplot(1,1,1)
    plot2.set_xlabel('$r$ [m]')
    plot2.set_ylabel('$\Phi_{0}(r)$ [V]')
    plot2.grid(color='grey', linestyle='-', linewidth=0.3)
    plot2.plot(matrix_spl[:,0],phi0_ap,color='red',\
               linestyle='dashed', label='$\Phi_{0}^{\mathrm{ap}}$')
    plot2.plot(matrix_spl[:,0],phi0_ap_qn,color='black',\
               label='$\Phi_{0}^{\mathrm{ap+qn}}$')
    plt.legend(loc=2)
    savefig('phi_r_gsrake_'+ datafile +'.eps')
    
#   Map for phi1(r,theta)
    figure3 = figure(num=None, figsize=(7.0,6.0), dpi=100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot3 = plt.subplot(1,1,1)
    plot3.set_xlabel('$\\sqrt{s}$')
    plot3.set_ylabel('$\\theta$ [rad]')

#   plot3.set_zlabel('$\phi_1(r,\theta)$ [V]')
    X,Y = meshgrid(matrix_spl[:,0], theta)
    cax = plot3.pcolor(matrix_spl[:,0]/a, theta, phi1.transpose())
#    title('${\Phi}_1(r,\\theta)$ [V]')
    plot3.axis([0, 1, 0, 2*pi])
    colorbar(cax)
    savefig('phi_map_gsrake_'+ datafile +'.eps')
    
#   Plot bottom right
    figure4 = figure(num=None, figsize=(6.0,6.0), dpi=100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot2 = plt.subplot(1,1,1)
    plot2.set_xlabel('$s$ ')
    plot2.set_ylabel('$\Phi_{0}(s)$ [V]')
    plot2.grid(color='grey', linestyle='-', linewidth=0.3)
    plot2.plot((matrix_spl[:,0]/a)**2.,phi0_ap,color='red',\
               linestyle='dashed', label='$\Phi_{0}^{\mathrm{ap}}$')
    plot2.plot((matrix_spl[:,0]/a)**2,phi0_ap_qn,color='black',\
               label='$\Phi_{0}^{\mathrm{ap+qn}}$')
    plt.legend(loc=2)
    savefig('phi_s_gsrake_'+ datafile +'.eps')
    
    show()
#   Writing output file for euterpe
    matrix_spl[:,0] = (matrix_spl[:,0]/a)**2.
#
#   If I want to write the 0-ordered potential instead of
#   the electric field, uncomment the following 2 lines.
#    matrix_spl[:,1] = phi0_ap
#    matrix_spl[:,2] = phi0_ap_qn    
    for i in range(0,n_spl):
        for j in range (0,n_fourier*2+3):
            f.write(str(format(matrix_spl[i,j])))
            f.write('\t')
        f.write('\n')

    f.close()


def min_max(array):
#
#   Function that returns the maximum value of
#   a real 2D array and the position.
#
    ni        = shape(array)[0]
    nj        = shape(array)[1]
    max_value = 0.0
    min_value = 0.0
    
    for i in range(0,ni):
        for j in range(0,nj):
            if array[i,j] > max_value:
                imax      = i
                jmax      = j
                max_value = array[i,j]
            if array[i,j] < min_value:
                imin      = i
                jmin      = j
                min_value = array[i,j]
                
    return(min_value,max_value)

def er_s_build(equil='none', datafile='none', fsl='rho', er_col=1, rho_col=0, units=1.0,\
               n_spl=200, pot=0, coeffs='none', output=None, plot=0):
    #    More than once in my life I will received a datafile
    #    with Er(rho) instead of Er(s) with s a normalized flux.
    #    This subroutine converts that file into an ef(s) with
    #    s points equidistant.
    #
    #    datafile = 'none' ==> f is taken as a function of s.
    #

    if datafile == 'none':
        s         = np.linspace(0,1.,n_spl)

        # 43387/88 coeffs=[  118.046, 876.189, -2590.74,  2488.95, -1024.58,  154.96]
        # 43391    coeffs=[-2254.62, 8628.65, -12654.3,   8998.13, -3128.03,  428.639]
        # 43392    coeffs=[ 9968.61, -30927.6,  38017.9, -23127.2,  6959.12, -827.509]
        # 43391/92 coeffs=[-470.324,  1755.47, -2459.58,   1655.49,  543.293,  71.2157]
        
##        er_s      = -5000*sqrt(s)*sin(3*((sqrt(s)**3)))
##        er_s      = -3588.0*1.4*s**0.
##        # Teresa ion root 43387-8
##        a         = 434.103
##        b         = -799.029
##        c         = 477.95
##        d         = -94.2868
##        # Teresa electron root 43391-2
##        a               = 145.74  
##        b               = -236.241
##        c               = 120.039 
##        d               = -16.3986

        er_s      = (coeffs[0]*(s**0.5)**5+\
                     coeffs[1]*(s**0.5)**4+\
                     coeffs[2]*(s**0.5)**3+\
                     coeffs[3]*(s**0.5)**2+\
                     coeffs[4]*(s**0.5)**1+\
                     coeffs[5])*1000
        
        amin  = rmin(equil)[0]
    else:
        in_data   = datafile
        # out_data = datadir() + 'er_s.dat'
        # myfile   = open(in_data)
        # content  = myfile.read()
        data = loadtxt(in_data, usecols=(rho_col, er_col))
        # Interpolation s vector
        s   = np.linspace(0,1.,n_spl)
        # Flux surface label is r
        amin  = rmin(equil)[0]

        if fsl == 'rho' :
            # Flux surface label is rho ~ r/a
            tck     = interpolate.splrep(data[:,0]**2.,data[:,1]*units,s=0)
            dfsl_dr = 1 / amin
            
        elif fsl == 's':
            # Flux surface label is s=rho**2.
            tck   = interpolate.splrep(data[:,0],data[:,1]*units, k=3, s=0)
            dfsl_dr = 2*sqrt(s)/amin
        elif fsl == 'reff':
            # Flux surface label is r
            tck   = interpolate.splrep((data[:,0]/amin)**2.,data[:,1]*units,s=0)
            dfsl_dr = 1.0


        if pot == 0:
            er_s      = interpolate.splev(s,tck,der=0)
        elif pot == 1:
            pot0      =   interpolate.splev(s,tck,der=0)
            er_s      = - interpolate.splev(s,tck,der=1) * dfsl_dr
                
    # Output file writting
    # out_file  = datadir() + 'er_s.dat'
    out_file  = './er_s.dat'
    f           = open(out_file,'w')
    f.write('# Postprocessed output from file: ' + datafile + '\n')
    if output == 'edi':
        f.write('# s'  + '\t\t' + 'dPhi0/ds [V]' + '\n')           
    else:
        f.write('# s'  + '\t\t' + 'E_r [V/m]' + '\n')
    f.write(str(amin) + '\n')
    f.write(str(n_spl) + '\n')

    for i in range(0,n_spl):
        f.write(str(format5(s[i])))
        f.write('\t')
        if output == 'edi':
            if s[i] != 0.0:
                f.write(str(format5(-er_s[i]*amin/2.0/sqrt(s[i]))))
            else:
                f.write(str(format5(0.0)))
        else:
            f.write(str(format5(er_s[i])))
        f.write('\n')
    f.close()


    if plot == 1:
        fig, ax1 = plt.subplots(figsize=(7, 6))
        subplots_adjust(left=0.2, bottom=0.2, right=0.8, top=0.9,\
                        wspace=0.00, hspace=0.00)
        t = np.arange(0.01, 10.0, 0.01)      
        
        ax1.plot(sqrt(s), er_s/1000, 'b-', linewidth = 2)
        ax1.plot(sqrt(data[:,0]), data[:,1]/1000., 'ro', linewidth = 2)
        ax1.set_xlabel('$r/a$')
        
        # Make the y-axis label and tick labels match the line color.
        ax1.set_ylabel('$E_r$ [kV/m]', color='b')
        
        if pot==1 :
            for tl in ax1.get_yticklabels():
                tl.set_color('b')
                ax2 = ax1.twinx()
                ax2.plot(sqrt(s), pot0, 'r.', linewidth = 2)
                ax2.set_ylabel('$\Phi_0$ [kV]', color='r')
                for tl in ax2.get_yticklabels():
                    tl.set_color('r')
        plt.show()


def surfdens(case, quant='dens', species=0, t0=0, tf=0,
             norm=1, crange=['none', 'none']):
    
    surfile  = runsdir() + case + '/flsurf_dens.dat'
    time     = read_history(case,0, species)
    flux     = read_history(case,10,species)
    bin_data = open(surfile, 'rb')


    t0 = max(t0, time[0])
    if tf==0:
        tf = time[size(time)-1]
    else:
        tf = min(tf, time[size(time)-1])
    
    print "\nAnalysis performed in simulation time range : [", str(format2(t0)),\
          ", ", str(format2(tf)), "]\n"

    if quant == 'dens':
        normval = read_npars(case)[1]

    # We read the first block of data
    rb_value(bin_data,'1i')
    vernum  = rb_value(bin_data,'1d'); rb_value(bin_data)
    cpx_ver = rb_value(bin_data,'1i'); rb_value(bin_data)
    elmag   = rb_value(bin_data,'1i'); rb_value(bin_data)
    nchi    = rb_value(bin_data,'1i')
    nphi    = rb_value(bin_data,'1i')
    nfp     = rb_value(bin_data,'1i'); rb_value(bin_data)
    rhfs    = rb_value(bin_data,'1d'); rb_value(bin_data)
    rg0     = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    zg0     = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    simtime = rb_value(bin_data,'1d'); rb_value(bin_data)
    m0      = rb_value(bin_data,'1i')
    n0      = rb_value(bin_data,'1i'); rb_value(bin_data)
    quant0  = rb_value(bin_data,str(nchi*nphi) + 'd')
    rb_value(bin_data,'1i')
    #
    rg      = reshape(rg0  ,   (nphi,nchi))
    zg      = reshape(zg0  ,   (nphi,nchi))
    quant   = reshape(quant0 , (nphi,nchi))
    
   # Let's construct theta and phi arrays
    phi_arr = phi_array(nfp, nphi, per=1)
    chi_arr = chi_array(nfp, nchi, per=1)

    quant_sum = empty((nphi,nchi), dtype='float')
    quant_avr = empty((nphi,nchi), dtype='float')
    i         = 0 # average counter
    j         = 0 # total loop counter
    while 1:
        rb_value(bin_data,'1i')
        simtime = rb_value(bin_data,'1d'); rb_value(bin_data)
        m0      = rb_value(bin_data,'1i')
        n0      = rb_value(bin_data,'1i'); rb_value(bin_data)
        quant0  = rb_value(bin_data,str(nchi*nphi) + 'd')
        quant   = reshape(quant0,(nphi,nchi)); rb_value(bin_data,'1i')
        j       = j + 1
#       Time average of the potential
        if simtime > t0 and simtime < tf:
            quant_sum = quant_sum + quant
            i       = i+1
            quant_avr = quant_sum / float(i)
        if simtime >= tf :
            break
        
    quant_avr_per = per(quant_avr)
    print quant_avr
    if "/" in case:
        hpc      = case.split("/")[0]
        run      = case.split("/")[1]
        filename = datadir() + 'dens_' + hpc + '_' + run + '.dat'
    else:
        filename = datadir() + 'dens_' + run + '.dat'
        
    f        = open(filename,'w')
    f.write('# Postprocessed output from file: ' + surfile + '\n')
    f.write('# Time average interval         : ' + str(t0) + '\t' + str(tf)  +'\n')
    f.write('# load_s0, nchi, nphi, nfp' + '\n#\n')
    f.write(str(load_s0(case))+'\n')
    f.write(str(nchi+1)+'\n')
    f.write(str(nphi+1)+'\n')
    f.write(str(nfp)+'\n')
    for i_chi in range(0,nchi+1):
        for i_phi in range(0,nphi+1):
            f.write(str(quant_avr_per[i_phi,i_chi]*normval)+'\t')
        f.write('\n')
        
    # Color map of dens
    plmap(xdata=phi_arr, ydata=chi_arr, zdata=quant_avr_per.transpose()*normval,\
          xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$n_{1}(\\phi,\theta)\ [m^{-3}]$',num=1)
    
        
def phi_array(nfp=5, nphi=128, per=1):

    array = linspace(0, 2*pi/(nfp), nphi+1)
    
    if per == 0:
        return array[0:nphi]
    elif per == 1:
        return array
        
def chi_array(nfp=5, nchi=128, per=1):

    array = linspace(0, 2*pi, nchi+1)
    
    if per == 0:
        return array[0:nchi]
    elif per == 1:
        return array        

def plflsurf(case, species=-1, t0=0, tf=0, phi_avrg=0, dens=0,\
             showit=1, phi=-1.0, probe=[0.,0.], si=0, title='None',\
             max_m=4, max_n=4, norm=1, crange=['none', 'none']):
#   This function, reads the file ./flsurf_phi.dat present
#   on the directory of a certain case
#   and return the averaged potential between two
#   times (time_ini, time_end).

    phi_file =  runsdir() + case + '/flsurf_phi.dat'
    bin_data = open(phi_file, 'rb')
    time_ini=t0
    time_end=tf
#

#   History relevant data
    time     = read_history(case,0, species)
    flux     = read_history(case,10,species)

    tf       = time_end
    t0       = time[0]
    if time_ini > 0:                              t0 = time_ini
    if time_end == 0 or time_end > tsim(case, species)[1]: tf = tsim(case, species)[1]
    
    print "\nAnalysis performed in simulation time window : [", str(format2(t0)),\
          ", ", str(format2(tf)), "]\n"
    
#   EUTERPE necessary norm. parameters for SI units    
    nstar    = read_npars(case)[1]
    rstar    = read_npars(case)[2]
    vstar    = read_npars(case)[3]
    bstar    = read_npars(case)[4]
    omstar   = read_npars(case)[5]
    efstar   = read_npars(case)[6]
    sfactor  = read_npars(case)[8]
    a        = rmin(case)[0]
    phi_star = rstar*efstar

    norm_flux       = vstar*nstar*(rstar**2.)*sfactor*1.e19
    norm_flux_dens  = nstar*1.e19*vstar*(1./rstar)*(a/2./sqrt(load_s0(case)))
  
    rb_value(bin_data,'1i')
    vernum  = rb_value(bin_data,'1d'); rb_value(bin_data)
    cpx_ver = rb_value(bin_data,'1i'); rb_value(bin_data)
    elmag   = rb_value(bin_data,'1i'); rb_value(bin_data)
    nchi    = rb_value(bin_data,'1i')
    nphi    = rb_value(bin_data,'1i')
    nfp     = rb_value(bin_data,'1i'); rb_value(bin_data)
    rhfs    = rb_value(bin_data,'1d'); rb_value(bin_data)
    rg0     = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    zg0     = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
#    bmod0   = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    simtime = rb_value(bin_data,'1d'); rb_value(bin_data)
    m0      = rb_value(bin_data,'1i')
    n0      = rb_value(bin_data,'1i'); rb_value(bin_data)
    pot0    = rb_value(bin_data,str(nchi*nphi) + 'd')
    rb_value(bin_data,'1i')
    #
    # in ML and python the convention of columns/rows is changed
    # the element (1,2) in ML is the (1,0) in python
    #
    # reshape ==> reshape(#columnas, #filas)
    rg      = reshape(rg0  , (nphi,nchi))
    zg      = reshape(zg0  , (nphi,nchi))
    pot     = reshape(pot0 , (nphi,nchi))
#    bmod    = reshape(bmod0, (nphi,nchi))
    
   # Let's construct theta and phi arrays
   #... and if desired set a probe at a certain position (0,0) default
   
    phi_arr = zeros(nphi+1)
    chi_arr = zeros(nchi+1)

    probe_pot = zeros(size(time))
    delta_phi = 2*pi/(nfp*(nphi))
    delta_chi = 2*pi/(nchi)
    probe_phi = int(probe[0]/delta_phi)
    probe_chi = int(probe[1]/delta_chi)
    
    for j in range(0,nphi+1):
        phi_arr[j]= 2*pi*j/(nfp*(nphi))
    for j in range(0,nchi+1):
        chi_arr[j]=2*pi*j/(nchi)
    z       = zg
    
            
    pot_sum  = zeros([nphi,nchi])
    probe_pot_sum = 0.
    i        = 0 # average counter
    j        = 0 # total loop counter

    while 1:
        rb_value(bin_data,'1i')
        simtime = rb_value(bin_data,'1d'); rb_value(bin_data)
        m0      = rb_value(bin_data,'1i')
        n0      = rb_value(bin_data,'1i'); rb_value(bin_data)
        pot0    = rb_value(bin_data,str(nchi*nphi) + 'd')
        pot     = reshape(pot0,(nphi,nchi))
        rb_value(bin_data,'1i')
#
        probe_pot[j] = pot[probe_phi,probe_chi]
        j            = j + 1
#       Time average of the potential
        if simtime > t0 and simtime < tf:
            pot_sum = pot_sum + pot
            probe_pot_sum = probe_pot_sum + probe_pot[j-1]
            i       = i+1
            pot_avr = pot_sum / float(i)
            probe_pot_avr = probe_pot_sum /  float(i)
            
#        if simtime > time[len(time)-2] :
        if simtime > tf :
            break

        probe_pot[size(probe_pot)-1]=probe_pot[size(probe_pot)-3]
        probe_pot[size(probe_pot)-2]=probe_pot[size(probe_pot)-3]        
#
#   We construct a periodic boundary for the
#   potential grid.
#   pot_avr_per  : array with the e.s. potential components avaraged
#   on time and made periodic at the boundaries.
#
    pot_avr_per = zeros([nphi+1,nchi+1])
#    bmod_per    = zeros([nphi+1,nchi+1])

    for i_chi in range(0,nchi+1):
        for i_phi in range(0,nphi):
            if i_chi < nchi:
                pot_avr_per[i_phi,i_chi]= pot_avr[i_phi,i_chi]
#                bmod_per[i_phi,i_chi]   = bmod[i_phi,i_chi]
            else:
                pot_avr_per[i_phi,i_chi]= pot_avr[i_phi,0]
#                bmod_per[i_phi,i_chi]   = bmod[i_phi,0]

    for i_phi in range(0,nphi+1):
        for i_chi in range(0,nchi):
            if i_phi < nphi:
                pot_avr_per[i_phi,i_chi]= pot_avr[i_phi,i_chi]
#                bmod_per[i_phi,i_chi]   = bmod[i_phi,i_chi]
            else:
                pot_avr_per[i_phi,i_chi]= pot_avr[0,i_chi]
#                bmod_per[i_phi,i_chi]   = bmod[0,i_chi]
                
    pot_avr_per[nphi,nchi]= pot_avr[0,0]
#    bmod_per[nphi,nchi]   = bmod[0,0]
#
#   pot_avrg_phi : array with the e.s. potential as a function of theta
#   after averating on the phi coordinate
#
    pot_avrg_phi = zeros([nchi+1])
    if phi_avrg == 1:
        for i_chi in range(0,nchi+1):
            for i_phi in range(0,nphi+1):
                pot_avrg_phi[i_chi] = pot_avrg_phi[i_chi] + pot_avr_per[i_phi,i_chi]/nphi
#
#   Fourier transform of the potential
    ft     = fft2(pot_avr_per[0:nphi+1,0:nchi+1])
    fts    = fftshift(ft)
    
    nphi_c = nphi/2 + 1
    nchi_c = nchi/2 + 1


    ftsc   = zeros([max_m+1,max_n*2+1])

    ftsc   = fts[nphi_c-1:nphi_c+max_n,nchi_c-max_m-1:nchi_c+max_m]

    ftsc_max = max(abs(min_max(ftsc.real)[0]),\
                        abs(min_max(ftsc.real)[1]),\
                        abs(min_max(ftsc.imag)[0]),\
                        abs(min_max(ftsc.imag)[1]))
    ftsc[0,max_m]      = ftsc[0,max_m]/2. # Division /2 of the 00 component
    ftsc_norm          = ftsc/ftsc_max
    

    print '(m,0) Fourier coeffs -----------------'
    print ftsc[0,4:9]
    print '(m,1) Fourier coeffs -----------------'
    print ftsc[1,:]
    print '(m,2) Fourier coeffs -----------------'
    print ftsc[2,:]
    print '(m,3) Fourier coeffs -----------------'
    print ftsc[3,:]
    print '(m,4) Fourier coeffs -----------------'
    print ftsc[4,:]

#
#   Print main Fourier coeffs (real part)
    print '# Main Fourier components (Real part)'
    print '# 1(0,0)', '2(1,0)', '3(2,0)','4(3,0)',\
          '5(-3,1)','6(-2,1)','7(-1,1)','8(0,1)','9(1,1)','10(2,1)','11(3,1)'\
          '12(-3,2)','13(-2,2)','14(-1,2)','15(0,2)','16(1,2)','17(2,2)','18(3,2)'
    print map(float63, (ftsc.real[0,4],ftsc.real[0,5],ftsc.real[0,6],ftsc.real[0,7],\
          ftsc.real[1,1],ftsc.real[1,2],ftsc.real[1,3],ftsc.real[1,4],ftsc.real[1,5],ftsc.real[1,6],ftsc.real[1,7],\
          ftsc.real[2,1],ftsc.real[2,2],ftsc.real[2,3],ftsc.real[2,4],ftsc.real[2,5],ftsc.real[1,6],ftsc.real[2,7]))
    print ''
    print '# Main Fourier coeffs (imaginary part)'
    print '# 1(0,0)', '2(1,0)', '3(2,0)','4(3,0)',\
          '5(-3,1)','6(-2,1)','7(-1,1)','8(0,1)','9(1,1)','10(2,1)','11(3,1)'\
          '12(-3,2)','13(-2,2)','14(-1,2)','15(0,2)','16(1,2)','17(2,2)','18(3,2)'
    print map(float63,(ftsc.imag[0,4], ftsc.imag[0,5],ftsc.imag[0,6],ftsc.imag[0,7],\
          ftsc.imag[1,1],ftsc.imag[1,2],ftsc.imag[1,3],ftsc.imag[1,4],ftsc.imag[1,5],ftsc.imag[1,6],ftsc.imag[1,7],\
          ftsc.imag[2,1],ftsc.imag[2,2],ftsc.imag[2,3],ftsc.imag[2,4],ftsc.imag[2,5],ftsc.imag[2,6],ftsc.imag[2,7]))
#
#   We write the output data that will be read by
#   EUTERPE as input.
#
    if "/" in case:
        hpc      = case.split("/")[0]
        run      = case.split("/")[1]
        out_data = datadir() + 'phi2d_' + hpc + '_' + run + '.dat'
        bmod_data = datadir() + 'bmod_' + hpc + '_' + run + '.dat'
        probe_data = datadir() + 'probe_' + hpc + '_' + run + '.dat'
        phi_avrg_phi_data = datadir() + 'phi_avrg_phi_' + hpc + '_' + run + '.dat'
        phiplane_data = datadir() + 'phiplane_' + hpc + '_' + run + '.dat'
        fig1_name = plotdir() + 'phi2d_' + hpc + '_' + run + '.eps'
        fig2_name = plotdir() + 'flux_t_' + hpc + '_' + run + '.eps'
        fig3_name = plotdir() + 'phi1d_' + hpc + '_' + run + '.eps'
        fig4_name = plotdir() + 'refour_' + hpc + '_' + run + '.eps'
        fig5_name = plotdir() + 'imfour_' + hpc + '_' + run + '.eps'
        fig6_name = plotdir() + 'bmod_' + hpc + '_' + run + '.eps'
        fig7_name = plotdir() + 'n2d_' + hpc + '_' + run + '.eps'
        fig9_name = plotdir() + 'forces_' + hpc + '_' + run + '.eps'
    else:
        out_data = datadir() + 'phi2d_' + case + '.dat'
        bmod_data = datadir() + 'bmod_' + case + '.dat'
        probe_data = datadir() + 'probe_' + case + '.dat'
        phi_avrg_phi_data = datadir() + 'phi_avrg_phi_' + case + '.dat'
        phiplane_data = datadir() + 'phiplane_' + case + '.dat'
        fig1_name = plotdir() + 'phi2d_' + '_' + case + '.eps'
        fig2_name = plotdir() + 'flux_t_' + '_' + case + '.eps'
        fig3_name = plotdir() + 'phi1d_' + '_' + case + '.eps'
        fig4_name = plotdir() + 'refour_' + '_' + case + '.eps'
        fig5_name = plotdir() + 'imfour_' + '_' + case + '.eps'
        fig6_name = plotdir() + 'bmod_' +'_' + case + '.eps'
        fig7_name = plotdir() + 'n2d_' + '_' + case + '.eps'
        fig9_name = plotdir() + 'forces_' + '_' + case + '.eps'
        
    f        = open(out_data,'w')
    f.write('# Postprocessed output from file: ' + phi_file + '\n')
    f.write('# Time average interval         : ' + str(t0) + '\t' + str(tf)  +'\n')
    f.write('# load_s0, nchi, nphi, nfp' + '\n#\n')
    f.write(str(load_s0(case))+'\n')
    f.write(str(nchi+1)+'\n')
    f.write(str(nphi+1)+'\n')
    f.write(str(nfp)+'\n')
    
    g        = open(bmod_data,'w')
    g.write('# |B|(theta, phi) for run ' + case + '\n')
    g.write('# load_s0, nchi, nphi, nfp' + '\n#\n')
    g.write(str(load_s0(case))+'\n')
    g.write(str(nchi+1)+'\n')
    g.write(str(nphi+1)+'\n')
    g.write(str(nfp)+'\n')

    
    if phi_avrg == 1:
        h        = open(phi_avrg_phi_data,'w')
        h.write('# Phi1(theta) for run ' + case + '\n')
        h.write('# load_s0, nchi, nphi, nfp' + '\n#\n')
        h.write('# ' + str(load_s0(case))+'\n')
        h.write('# ' + str(nchi+1)+'\n')
        h.write('# ' + str(nphi+1)+'\n')
        h.write('# ' + str(nfp)+'\n')

        for i_chi in range(0,nchi+1):
            if si == 0:
                h.write(str(chi_arr[i_chi]) + '\t' +\
                        str(pot_avrg_phi[i_chi]) + '\n')
            elif si == 1:
                h.write(str(chi_arr[i_chi]) + '\t' +\
                        str(pot_avrg_phi[i_chi]*phi_star) + '\n')           

    i        = open(probe_data,'w')
    i.write('# Phi1 at probe position: ('       + \
                str(format(probe[0])) + ','     + \
                str(format(probe[1])) + ')'     + '\n')
    i.write('# Simtime [s]' + '\t' + 'Phi1 [V]' + '\n')

    for i_step in range(0, size(time) - 2):
        i.write(str(format(time[i_step]/omstar)) + '\t')
        if si == 1:
            i.write(str(format(probe_pot[i_step]*phi_star))   + '\t')
        elif si == 0:
            i.write(str(format(probe_pot[i_step]))   + '\t')
        i.write('\n')
        
    for i_chi in range(0,nchi+1):
        for i_phi in range(0,nphi+1):
            if si == 1:
                f.write(str(pot_avr_per[i_phi,i_chi]*phi_star)+'\t')
            elif si == 0:
                f.write(str(format5(pot_avr_per[i_phi,i_chi]))+'\t')                
#            g.write(str(bmod_per[i_phi,i_chi]*bstar)+'\t')
        f.write('\n')
    if phi > 0.0 :
        phi_loc = int(phi*pi/180./delta_phi)
        j        = open(phiplane_data,'w')
        j.write('# Phi1 at phi plane = '       + \
                str(format(phi)) + '\n')
        j.write('# theta [rad]' + '\t' + 'Phi1 [V]' + '\n')
        for i_chi in range(0,nchi+1):
            j.write(str(chi_arr[i_chi]) + '\t' +\
                    str(pot_avr_per[phi_loc,i_chi]*phi_star) + '\n')
#
#   We represent the potential as a function of theta and phi
#   in SI units, as it must be ....
#
#   FIGURE 1  FIGURE 1  FIGURE 1 FIGURE 1  FIGURE 1
    figure1 = figure(num=None, figsize=(7.0,6.0), dpi=100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    pot_avr_per_si = pot_avr_per*rstar*efstar
    
    plot1          = plt.subplot(1,1,1)
    plot1.set_ylabel('$\\theta$ [rad] ')
    plot1.set_xlabel('$\phi$ [rad]')


    if norm == 1:
        pot_avr_per_si = pot_avr_per_si / prof_values(case)[2] / 1000.
        if crange[0]!='none' or crange[1]!= 'none':
            cax            = plot1.pcolor(phi_arr, chi_arr, pot_avr_per_si.transpose(),\
                                          vmin=crange[0], vmax=crange[1])
        else:
            cax            = plot1.pcolor(phi_arr, chi_arr, pot_avr_per_si.transpose())
        cbar           = colorbar(cax)
        cbar.set_label('$e{\Phi}_1/T_i$')
    else:
        if crange[0]!='none' or crange[1]!= 'none':
            cax            = plot1.pcolor(phi_arr, chi_arr, pot_avr_per_si.transpose(),\
                                          vmin=crange[0], vmax=crange[1])
        else:
            cax            = plot1.pcolor(phi_arr, chi_arr, pot_avr_per_si.transpose())            
        cbar           = colorbar(cax)
        cbar.set_label('${\Phi}_1$ [V]')

    CS             = plot1.contour(phi_arr, chi_arr, pot_avr_per_si.transpose(),\
                                   colors ='black', linewidths = 1.5)
    plot1.clabel(CS, inline=1, fmt='%1.1f', fontsize=14)
    plot1.axis([0, 2*pi/nfp, 0, 2*pi])
    if 'tj20' in case:
        plot1.set_xticks([0,0.5,1.0, 1.5])
    if 'lhd' in case:
        plot1.set_xticks([0,0.2,0.4,0.6])        
    figure1.tight_layout(pad=0.15, h_pad=0, w_pad=0)
    savefig(fig1_name, dpi=50)
    print 'Maximum/Min/Variation of Phi1 value'
    phi1_max = max([max(l) for l in pot_avr_per_si])
    phi1_min = min([min(l) for l in pot_avr_per_si])
    dphi1    = phi1_max - phi1_min
    print ' '
    print 'Max/Min/Variation of Phi1'
    print map(scifloat,[phi1_max, phi1_min, dphi1])
    print ' '
    
#   FIGURE 2  FIGURE 2  FIGURE 2 FIGURE 2  FIGURE 2
    figure2 = figure(num=None, figsize=(6.0,6.0), dpi=100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot2   = plt.subplot(1,1,1)
    plot2.set_xlabel('$t$ [ms] ')
#    plot2.set_ylabel('$F_{i}$ [10$^{19}$ parts s$^{-1}$]')
    plot2.set_ylabel('$\\left<{\\bf \Gamma}\cdot\\nabla r \\right>_{\\mathrm{H}^{+}}$ [10$^{19}$ parts s$^{-1}$ m$^{-2}$]')
    plot2.grid(color='grey', linestyle='-', linewidth=0.3)    
    flux_si = flux*norm_flux_dens/1.e19
    time_si = time*1000./omstar
    plot2.plot(time_si, flux_si, color='blue')
    xmin, xmax, ymin, ymax = axis()
    if(ymin == 0.0): ymin = 0.001
    plot2.barh(ymin, (tf-t0)*1000/omstar, height=(ymax-ymin), \
               left=t0*1000/omstar, facecolor='yellow', alpha=0.3)

    
    savefig(fig2_name)
#   FIGURE 3  FIGURE 3  FIGURE 3 FIGURE 3  FIGURE 3
    if phi_avrg == 1:
        figure3 = figure(num=None, figsize=(6.0,6.0), dpi=100)
        subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                        wspace=0.00, hspace=0.00)
        plot3   = plt.subplot(1,1,1)
        plot3.set_xlabel('$\\theta$ [rad] ')
        plot3.set_ylabel('$\\left<{\Phi}_{1}\\right>_{\\phi}$ [V]') 
        plot3.plot(chi_arr, pot_avrg_phi*rstar*efstar, color='red')
        plot3.grid(color='grey', linestyle='-', linewidth=0.3)
        xlim( (0, 2.*pi) )
        savefig(fig3_name)           


#   FIGURE 4  FIGURE 4  FIGURE 4 FIGURE 4  FIGURE 4
    nth = arange(-max_m , max_m+1 , 1)
    nph = arange(0      , max_n+1 , 1)

    figure4 = figure(num=None, figsize=(7.0,6.0), dpi=100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot4          = plt.subplot(2,1,1)

    ax1 = Axes3D(figure4)
    ax1.view_init(22,-65)
    for ith in range (0,2*max_m+1):
        for iph in range (0,max_n+1):
            repart = abs(ftsc_norm[iph,ith].real)
            impart = abs(ftsc_norm[iph,ith].imag)
            if(iph==0 and ith<max_m):
                repart = 0.0
                impart = 0.0
                
            ax1.bar3d(nth[ith]-0.2,nph[iph]-0.3,0.0,0.5,0.5, repart, color='g')

    ax1.set_xlabel('$m$')
    ax1.set_ylabel('$n$')
    ax1.set_xticks(arange(-max_m, max_m+1, 2))
    ax1.set_zticks([0,1])
    ax1.set_yticks(arange(0, max_n+1, 2))    
    ax1.set_zlabel('$\\left|\Re(\Phi_{1mn})\\right|$ norm.')
    ax1.set_zlim3d([0,1])
    figure4.tight_layout(pad=0.15, h_pad=0, w_pad=0)
    savefig(fig4_name)

#   FIGURE 5  FIGURE 5  FIGURE 5 FIGURE 5  FIGURE 5
    figure5 = figure(num=None, figsize=(7.0,6.0), dpi=100)
    subplots_adjust(left=0.0, bottom=0.0, right=20, top=1.0,\
                    wspace=0.00, hspace=0.00)
    plot5          = plt.subplot(2,1,2)


    

    ax2 = Axes3D(figure5)
    ax2.view_init(22,-65)
    for ith in range (0,2*max_m+1):
        for iph in range (0,max_n+1):
            repart = abs(ftsc_norm[iph,ith].real)
            impart = abs(ftsc_norm[iph,ith].imag)
            if(iph==0 and ith<max_m):
                repart = 0.0
                impart = 0.0
                
            ax2.bar3d(nth[ith]-0.2,nph[iph]-0.3,0.0,0.5,0.5, impart, color='r')
    
    ax2.set_xlabel('$m$')
    ax2.set_ylabel('$n$')
    ax2.set_xticks(arange(-max_m, max_m+1, 2))
    ax2.set_zticks([0,1])
    ax2.set_yticks(arange(0, max_n+1, 2))
    ax2.set_zlabel('$\\left|\Im(\Phi_{1mn})\\right|$ norm.')
    ax2.set_zlim3d([0,1])
    figure5.tight_layout(pad=0.15, h_pad=0, w_pad=0)
    savefig(fig5_name)

#   FIGURE 6  FIGURE 6  FIGURE 6 FIGURE 6  FIGURE 6
##    figure6 = figure(num=None, figsize=(7.0,6.0), dpi=100)
##    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
##                    wspace=0.00, hspace=0.00)
##    bmod_per_si    = bmod_per*bstar
##    plot6          = plt.subplot(1,1,1)
##    plot6.set_ylabel('$\\theta$ [rad] ')
##    plot6.set_xlabel('$\phi$ [rad]')
##    cax    = plot6.pcolor(phi_arr, chi_arr, bmod_per_si.transpose())
##    colorbar(cax)#
##    CS2 = plot6.contour(phi_arr, chi_arr, bmod_per_si.transpose(), colors ='black', linewidths = 1.5)
##    plot6.clabel(CS2, inline=1, fmt='%1.1f', fontsize=14)
##    figure6.suptitle('$|B|(\\theta,\phi)$ [T]')
##    plot6.axis([0, 2*pi/nfp, 0, 2*pi])
##    savefig(fig6_name)


    if dens == 1:
        #   FIGURE 7  FIGURE 7  FIGURE 7 FIGURE 7  FIGURE 7
        figure7 = figure(num=None, figsize=(7.0,6.0), dpi=100)
        subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                        wspace=0.00, hspace=0.00)
        
        #   Chapuza mode    
        ne0            = 8.915264e+18
        te0            = 1.132733e+02 * 1.609e-19
        cons           = 1.609e-19*ne0/6./te0
        nz             = 1.485877e+17
        nztilde        = (pot_avr_per_si.transpose())*cons
        nztot          = nztilde + nz
        
        plot7          = plt.subplot(1,1,1)
        plot7.set_ylabel('$\\theta$ [rad] ')
        plot7.set_xlabel('$\phi$ [rad]')
        cax            = plot7.pcolor(phi_arr, chi_arr, nztot/nz - 1)
        plot7.xaxis.set_major_locator(MultipleLocator(0.4))
        cbar           = colorbar(cax)
        cbar.set_label('$\\tilde{n}_{Z}/n_{Z0}-1$')
        CS             = plot7.contour(phi_arr, chi_arr, nztot/nz - 1,\
                                       colors ='black', linewidths = 1.5)
        plot7.clabel(CS, inline=1, fmt='%1.1f', fontsize=14)
        #    title('$\\left<\\tilde{\Phi}\\right>_{t}(\\theta,\phi)$ [V]')
        plot7.axis([0, 2*pi/nfp, 0, 2*pi])
        savefig(fig7_name)


    #   FIGURE 2  FIGURE 2  FIGURE 2 FIGURE 2  FIGURE 2
    figure8 = figure(num=None, figsize=(6.0,6.0), dpi=100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot8   = plt.subplot(1,1,1)
    plot8.set_xlabel('$t$ [ms] ')
    plot8.set_ylabel('$\Phi_{1}$ [V]')
    plot8.grid(color='grey', linestyle='-', linewidth=0.3)    
    time_si = time*1000./omstar
    plot8.plot(time_si, probe_pot*rstar*efstar, color='blue')
    plot8.axhline(pot_avr_per_si[probe_phi,probe_chi], linewidth=4, color='r')
    plot8.set_xlim(0.0, tf*1000./omstar)
    xmin, xmax, ymin, ymax = axis()
    if(ymin == 0.0): ymin = 0.001
    plot8.barh(ymin, (tf-t0)*1000/omstar, height=(ymax-ymin), \
               left=t0*1000/omstar, facecolor='yellow', alpha=0.3)
    figure8.suptitle('Probe at $(\phi,\ \\theta)=('+format3(probe[0])+',\ '+format3(probe[1])+ ')$')
    print 'Average potential at probe', probe,' = ', \
          probe_pot_avr*rstar*efstar
    


#   FIGURE 9  FIGURE 9  FIGURE 9 FIGURE 9  FIGURE 9
#   We plot here: -Er + Phi1 T'/T (with T'=dT/dr)
#
##    figure9 = figure(num=None, figsize=(7.0,6.0), dpi=100)
##    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
##                    wspace=0.00, hspace=0.00)
##    er_si    = er(case, plot=0, info=1)[0]
##    s_value  = prof_values(case)[0]
##    dTids    = prof_values(case)[1]
##    Ti       = prof_values(case)[2]
##    dLnTidr  = dTids * 2 * sqrt(s_value) / (Ti * a )
##    print 'dTi/dt /Ti = ', dLnTidr
##    phi1_si  = pot_avr_per*rstar*efstar
##    force_si = -er_si + phi1_si * dLnTidr
##    print 
##    pot_avr_per_si = pot_avr_per*rstar*efstar
##    plot9          = plt.subplot(1,1,1)
##    plot9.set_ylabel('$\\theta$ [rad] ')
##    plot9.set_xlabel('$\phi$ [rad]')
##    cax            = plot9.pcolor(phi_arr, chi_arr, force_si.transpose())
##    cbar           = colorbar(cax)
##    cbar.set_label('$-{\Phi}\'_0$+${\Phi}_1 T\'/T$ [V/m]')
##    #    pot_avr_per_si = pot_avr_per_si / prof_values(case)[2] / 1000.
##    #    cbar.set_label('$|e|{\Phi}_1/T_i$')
##    CS             = plot9.contour(phi_arr, chi_arr, force_si.transpose(),\
##                                   colors ='black', linewidths = 1.5)
##    plot9.clabel(CS, inline=1, fmt='%1.1f', fontsize=14)
###    title('$\\left<\\tilde{\Phi}\\right>_{t}(\\theta,\phi)$ [V]')
##    plot9.axis([0, 2*pi/nfp, 0, 2*pi])
##    savefig(fig9_name)

    show(block=False)
            

def proffit(equil='none', sp='e', profile_type=2, npoints=1000, s_norm=0.5,\
             t0=1.0, t1=1.0, t2=2.0, t3=1.5, tg=0.05, th=-0.5, tw=0.1,\
             n0=1.0, n1=1.0, n2=4.0, n3=2.0, ng=0.04, nh=0.1,  nw=0.2,\
             a=1.0):
    
    import physcon as pc
    rho = linspace(0.,1.0, npoints)

    if sp == 'e' :
        mass = pc.m_e
    elif sp == 'i':
        mass = pc.m_p
    q    = pc.e


    if equil != 'none' and sp=='e':
        t0 = lx_t0(equil, profile_type=profile_type, t0=t0, t1=t1, t2=t2/2., t3=t3,\
                    tg=tg, th=th, tw=tw, s_norm=0.5)
        print 'lx = ', te0

    if profile_type == 2:
        t       =   t0*(1.0 - t1*(rho**t2))**t3
        n       =   n0*(1.0 - n1*(rho**n2))**n3

        # Minor radius missing --> [dlntdrho^-1] = 1 not (m)
        dlntdrho = - t1*t2*t3*(1.0 - t1*(rho**t2))**(t3-1.0) *\
                   rho**(t2 - 1.)
        dlnndrho = - n1*n2*n3*(1.0 - n1*(rho**n2))**(n3-1.0) *\
                   rho**(n2 - 1.)        

    elif profile_type == 3:
        t        = tg - th + (1.0 - tg + th )*(1. - rho**t2)**t3 +\
                   th*(1.0 - exp(-rho**2./tw**2.))
        n        = ng - nh + (1.0 - ng + nh )*(1. - rho**n2)**n3 +\
                   nh*(1.0 - exp(-rho**2./nw**2.))

        dtdrho = -t2*t3*(1.0 - tg + th)*(1.0 - rho**t2)**(t3 - 1.0)*\
                  (rho**(t2 - 1.0)) + 2. *  th * exp(-rho**2./tw**2.) * rho / tw**2.
        dlntdrho = dtdrho / t
        dndrho = -n2*n3*(1.0 - ng + nh)*(1.0 - rho**n2)**(n3 - 1.0)*\
                   rho**(n2 - 1.0) + 2. *  nh * exp(-rho**2./nw**2.) * rho / nw**2.
        dlnndrho = dndrho / n

        t        = t * t0
        n        = n * n0
        print rho[0], dtdrho[0], nh/nw**2.


    Lt       = abs(1./dlntdrho)
    Ln       = abs(1./dlnndrho)
    
    vth      = sqrt(2.0 * t * pc.e * 1000./ mass)
    # B missing in omega --> [omega] = radians T^{-1} s^{-1}
    omega    = q / mass
    rhoth    = vth / omega
    
    deltat   = rhoth / Lt
    deltan   = rhoth / Ln
    

    # Te figure
    fig = figure(num=None, figsize=(11.69,8.27), dpi=100)
    subplots_adjust(left=None, bottom=0.1, right=None, top=None,
                    wspace=0.6, hspace=None)
    plot1 = plt.subplot(2,2,1)
    plot1.set_xlabel('$\\sqrt{s}$')
    plot1.set_ylabel('$T$ [keV], $n$ [$10^{19}$ m$^{-3}$]')
    plot1.grid(color='grey', linestyle='-', linewidth=0.3)
    plot1.plot(rho,t,color='red')
    plot1.plot(rho,n,color='blue')

    # L_Te figure
    plot2 = plt.subplot(2,2,2)
    plot2.set_xlabel('$\\sqrt{s}$')
    plot2.set_ylabel('$|\mathrm{d}\ln T/\mathrm{d}\\rho|^{-1}}$,\
    $|\mathrm{d}\ln n/\mathrm{d}\\rho|^{-1}}$')
    plot2.grid(color='grey', linestyle='-', linewidth=0.3)
    plot2.plot(rho,Lt,color='red')
    plot2.plot(rho,Ln,color='blue')
    ylim(0.0,10.0)

    # rho_th figure
    plot3 = plt.subplot(2,2,3)
    plot3.set_xlabel('$\\sqrt{s}$')
    plot3.set_ylabel('$\\rho_{L}$ [mm T$^{-1}$]')
    plot3.grid(color='grey', linestyle='-', linewidth=0.3)
    plot3.plot(rho,rhoth*1000.,color='red')


    # rho_th figure
    plot4 = plt.subplot(2,2,4)
    plot4.set_xlabel('$\\sqrt{s}$')
    plot4.set_ylabel('$\\delta_T$, $\\delta_n$ [m T$^{-1}$]')
    plot4.grid(color='grey', linestyle='-', linewidth=0.3)
    plot4.plot(rho,deltat,color='red')
    plot4.plot(rho,deltan,color='blue')
    
    show()  


def interpol(vector_x, vector_y, value_x, der=0):

    tck     = interpolate.splrep(vector_x, vector_y, s=0)
    value_y = interpolate.splev(value_x,tck,der=der)

    return value_y

def prof_values(case='none', svalue=0, fsl='s', z=0):

    prof_file =  runsdir() + case + '/profiles.def'
    data      =  loadtxt(prof_file, dtype='float')

    # Normalization values
    read_npars(case)
    tstar    = read_npars(case)[0]
    nstar    = read_npars(case)[1]
    svalue   = load_s0(case)
    
    #
    s         = data[:,0]
    dti       = data[:,1]*tstar; ti = data[:,2]*tstar
    dte       = data[:,3]*tstar; te = data[:,4]*tstar

    if fsl=='r':
        a       = rmin(case)[0]
        fslfact = 2 * sqrt(svalue) / a
        fslval  = sqrt(svalue) * a
    elif fsl=='s':
        fslfact = 1.0
        fslval  = svalue
    elif fsl=='rho':
        fslfact = 2 * sqrt(svalue)
        fslval  = sqrt(svalue)



    if kin(case)[4]=='t' or colwith(case)[4]=='t' or z!= 0:
        dtz       = data[:,5]*tstar; tz = data[:,6]*tstar
        dni       = data[:,7]*nstar; ni = data[:,8]*nstar
        dne       = data[:,9]*nstar; ne = data[:,10]*nstar
        dnz       = data[:,11]*nstar;nz = data[:,12]*nstar
        
        return map(scifloat, [fslval, fslfact*interpol(s,dti/ti,svalue), interpol(s,ti,svalue),\
                              fslfact*interpol(s,dte/te,svalue), interpol(s,te,svalue),\
                              fslfact*interpol(s,dtz/tz,svalue), interpol(s,tz,svalue),\
                              fslfact*interpol(s,dni/ni,svalue), interpol(s,ni,svalue),\
                              fslfact*interpol(s,dne/ne,svalue), interpol(s,ne,svalue),\
                              fslfact*interpol(s,dnz/nz,svalue), interpol(s,nz,svalue)])
    
    
    else:
        dni       = data[:,5]*nstar; ni = data[:,6]*nstar
        dne       = data[:,7]*nstar; ne = data[:,8]*nstar

        return map(scifloat, [fslval, fslfact*interpol(s,dti/ti,svalue), interpol(s,ti,svalue),\
               fslfact*interpol(s,dte/te,svalue), interpol(s,te,svalue),\
               fslfact*interpol(s,dni/ni,svalue), interpol(s,ni,svalue),\
               fslfact*interpol(s,dne/ne,svalue), interpol(s,ne,svalue)])



def er(case='none', plot=0, info=1, fsl='r', pot=0, msg=1):
    # This function plots the Er as a function of s^{1/2}=rho

    svalue   = load_s0(case)
    bstar    = read_npars(case)[4]
    
    if(neo_er(case)==1):
        erval=efield_r(case)
        omegae   = abs(erval) / (2. * pi * sqrt(svalue) *  rmin(case)[0])
        phi0val  = 0.0
        if msg == 1:
            print 'Er at s  [V/m]   = ', float(format(svalue)), ' : ', float(format(erval))
            print 'Omega_E  [Hz]    = ', float(omegae)
            print 'Tau_E    [s]     = ', float(1/omegae)
        return map(scifloat,[erval, phi0val, omegae, 1/omegae])
        exit
    elif(neo_er(case)==2):
        er_file = runsdir() + case + '/er_s.dat'
        sr = 4
    elif(neo_er(case)==3):
        er_file = runsdir() + case + '/gsrake.dat'
        sr = 10
    elif(neo_er(case)==4):
        er_file = runsdir() + case + '/gsrake.dat'
        sr = 10
        
    if(neo_er(case) != 1):
        data      =  loadtxt(er_file, dtype='float', skiprows=sr )
        s         = data[:,0]
        er        = data[:,1]

        phi0 = -cumtrapz(er,s, initial=0) # 99

        erval    = interpol(s,er,svalue)   

    omegae   = abs(erval) / (2. * pi * sqrt(svalue) *  rmin(case)[0])  

    if fsl=='r':
        fslfact = 1
    elif fsl=='s':
        a       = rmin(case)[0]
        fslfact = a / (2 * sqrt(svalue))

    erval = erval * fslfact
    
    phi0=phi0*fslfact
    phi0val=interpol(s, phi0, svalue)
        
    if info==1:
        if fsl == 'r': 
            print 'Er at s  [V/m]   = ', float(format(svalue)), ' : ', float(format(erval))
        if fsl == 's':
            print 'Es at s  [V]     = ', float(format(svalue)), ' : ', float(format(erval))
            
        print 'Omega_E  [Hz]    = ', float(omegae)
        print 'Tau_E    [s]     = ', float(1/omegae)
    
    if plot == 1:
        fig         = figure(num=None, figsize = (8.0,8.0), dpi = 100)
        subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                        wspace=0.00, hspace=0.00)
        plot1 = plt.subplot(1,1,1)
        plot1.set_xlabel('$r/a$')
        plot1.set_ylabel('$E_{r}$ [kV/m]')
        plot1.grid(color='gray', linestyle='-', linewidth=0.3)
        plot1.plot(sqrt(s),er/1000.,color='purple', linewidth=3)
        plot1.set_xlim(0.0, 1.0)
        plot1.set_ylim(-15, 15)

        fig         = figure(num=None, figsize = (8.0,8.0), dpi = 100)
        subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                        wspace=0.00, hspace=0.00)
        plot2 = plt.subplot(1,1,1)
        plot2.set_xlabel('$r/a$')
        plot2.set_ylabel('$\\Phi_0$ [kV]')
        plot2.grid(color='gray', linestyle='-', linewidth=0.3)
        plot2.plot(sqrt(s),phi0/1000., color='red', linewidth=3)
        plot1.set_xlim(0.1, 0.9)
            #plot1.set_ylim(-15, 15)





        
        
        if "/" in case:
            hpc      = case.split("/")[0]
            run      = case.split("/")[1]
            fig1_name = plotdir() + 'er_s' + '_' + hpc + '_' + run + '.eps'
        else:
            fig1_name = plotdir() + 'er_s' + '_' + case + '.eps'
            savefig(fig1_name)
        show()
            
    return map(scifloat,[erval, phi0val, omegae, 1/omegae])
                   
                   
def nu_star(case='none'):
    
    import physcon as pc

    nu_f_star = 0.0

    iota = read_npars(case)[9]
    nu_i = read_npars(case)[10]
    nu_e = read_npars(case)[11]

    if kin(case)[4]=='t' or colwith(case)[4]=='t':
        nu_f = read_npars(case)[12]
        
    r0   = rmin(case)[1]

    t_i  = prof_values(case)[2]
    t_e  = prof_values(case)[4]

    vthi  = sqrt(2.* t_i * pc.e * 1000. / pc.m_p)
    vpari = vthi / 2.
    
    vthe  = sqrt(2.* t_e * pc.e * 1000. / pc.m_e)
    vpare = vthe / 2.
        
    if(kin(case)[4]=='t'):
        t_f  = prof_values(case)[6]
        m_f  = mfdmp(case)
        vthf  = sqrt(2.* t_f  * 1000. * pc.e / pc.m_p / m_f)
        vparf = vthf / 2.
        nu_f_star = nu_f * r0 / vthf / abs(iota)

    nu_i_star = nu_i * r0 / vthi / abs(iota) 
    nu_e_star = nu_e * r0 / vthe / abs(iota) 

    return map(scifloat, [nu_i_star, nu_e_star, nu_f_star])

def data_fft(datafile='none', time_in=0, signal_in=0, t_col=0, signal_col=1, plot=0, \
             lapse=[0.0,0.0],
             
             xlabel  ='$t$ [ms]'  , ylabel  = '$\Phi_{1} [V]$',\
             x2label ='$f$ [kHz]', y2label = 'Power [a.u.]'):
    # 
    # This function reads the time and signal of a txt file
    # in order to perform the 1D DFT.
    #
    # SI units must be given
    #
    if datafile != 'none':
        data       = loadtxt(datafile, dtype='float')
        time_in    = data[:,t_col]
        signal_in  = data[:,signal_col]
        
    dt         = time_in[1]-time_in[0]
    f          = 1/dt
    print 'hola', dt
    loc_t0 = int(lapse[0]/dt)
    loc_tf = int(lapse[1]/dt)

##    if loc_tf != loc_t0 and loc_tf > loc_t0:
##        time   = time_in[loc_t0 : loc_tf-1]
##        signal = signal_in[loc_t0 : loc_tf-1]

##    if size(time_in)%2 != 0:
##        time   = time_in[0:size(time)-1]
##        signal = signal_in[0:size(signal)-1]

    time   = time_in[0:size(time_in)-1]
    signal = signal_in[0:size(signal_in)-1]

    # size gives the number of elements.
    signal_fft = fft(signal)
    freq       = range(0,size(signal_fft)) * f \
                 / (size(signal_fft)- 1)
    signal_fft = signal_fft[0:size(signal)/2]
    freq       = freq[0:size(signal)/2]
    
    # Writing out data
    
    fft_out  = datadir() + 'fft_out.dat'
    f        = open(fft_out,'w')
    f.write('# Processed file: ' + datafile )
    f.write('# freq [KHz]' + '\t' + '|signal_fft|' + '\n#\n')
    for iw in range(0, size(signal_fft)-1):
        f.write(str(freq[iw]/1000) +'\t')
        f.write(str(abs(signal_fft[iw])/max(abs(signal_fft)))+'\n')

    # Plotting the signal the DFT output
    figure1 = figure(num=None, figsize = (6.0,6.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot1           = plt.subplot(1,1,1)
    plot1.grid(color='grey', linestyle='-', linewidth=0.3)
    plot1.set_xlabel(xlabel)
    plot1.set_ylabel(ylabel) 
    plot1.plot(time_in*1000, signal_in,'b-')
    xmin, xmax, ymin, ymax = axis()
    plot1.barh(ymin, (lapse[1]-lapse[0])*1000, height=(ymax-ymin), \
               left=lapse[0]*1000, facecolor='yellow', alpha=0.3)
                             
    figure1 = figure(num=None, figsize = (6.0,6.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot2           = plt.subplot(1,1,1)
    plot2.grid(color='grey', linestyle='-', linewidth=0.3)
    plot2.set_xlabel(x2label)
    plot2.set_ylabel(y2label) 
    plot2.plot(freq/1000,abs(signal_fft)/max(abs(signal_fft)),'r-')
    plot2.set_xlim(0, 5)
    show(block=False)
    
    
def diagnose(case='none', diag='pfdensr', deltaf = 1, species='i', fix='none',\
            time=0.0, s=0.5, si=1, tavrg=0.0):
    #
    # This function reads (by default) the file profiles.dat present
    # in the directory 'case'.
    #
    # case           : run directory
    # diagnostic     : pfdenss (particle flux density with s as flux surface label)
    #                  pfdensr (particle flux density with r as flux surface label)
    #                  pf      (particle flux in parts s^{-1})
    #                  pdiff   (particle diffusivity)
    #                  efdenss (energy flux density with s as flux surface label)
    #                  efdensr (energy flux density with r as flux surface label)
    #                  hfdenss (heat flux density with s as flux surface label)
    #                  hfdensr (heat flux density with r as flux surface label)
    #                  hdiff   (head diffusivity)
    #                  pcurr   (parallel current)
    #                  
    # species(i,e,f) : if more than one kinetic species must be specied (default = 'i').
    # fix            : it allows to set a fixed time ('t') or a fix radial position ('s')
    # si             : it set the usage of SI units (1) or not (0)
    
    # Selecting the profiles.dat of the species requested
    import numpy as np

    SIMTIME, EFLUX0, EFLUX1, PFLUX0, PFLUX1, PCURR0, PCURR1,\
             VMOM0, VMOM1, VMOM2, NMARK = arange(0,11)

    pfdenss = [PFLUX1, 12, label_latex_pf(species, si)[0]]
    pfdensr = [PFLUX1, 13, label_latex_pf(species, si)[1]]
    pf      = [PFLUX1, 14, label_latex_pf(species, si)[2]]    
    efdenss = [EFLUX1, 15, label_latex_ef(species, si)[0]]
    efdensr = [EFLUX1, 16, label_latex_ef(species, si)[1]]
    
    if diag == 'pfdenss': diaglist = pfdenss
    if diag == 'pfdensr': diaglist = pfdensr   
    if diag == 'efdenss': diaglist = efdenss
    if diag == 'efdensr': diaglist = efdensr  
    
    if species=='i':
        datafile = runsdir() + case + profiles(case)[0]
    elif species=='e':
        datafile = runsdir() + case + profiles(case)[1]
    elif species=='f':
        datafile = runsdir() + case + profiles(case)[2]
        
    # Open de file just to count the lines    
    f = open(datafile,'r')            
    n_lines = len(f.readlines())
    f.close()
    
    # Open de file just to get data    
    f           = open(datafile,'r')
    version     = float(f.readline()) # version
    cversion    = int(f.readline())   # complex version
    emversion   = int(f.readline())   # electromagnetic version
    idontknow   = float(f.readline()) 
    NBIN_DIAG   = int(f.readline())   # number of bins
    
    # n_diag    : number of dianosed quantities
    # n_sim     : number of time steps simulated
    # matrix    : matrix containing all data
    # simtime   : array containing the simulation times.
    # counter_t : time-step counter
    # counter_b : radial (s) bin counter
    # delta_s   : radial bin width
    # svec      : vector with the mid-location of all bins
    n_diag      = 11                   
    n_sim       = (n_lines - 4 )/(NBIN_DIAG + 2)     
    matrix      = zeros([n_sim, NBIN_DIAG, n_diag])
    simtime     = []
    counter_t   = 0
    counter_b   = 0
    delta_s     = 1.0 / NBIN_DIAG
    svec        = linspace(delta_s/2 ,1.0-delta_s/2, NBIN_DIAG)

    for counter_t in range(0,n_sim):
        # map(type, array) convert the array of strings into an array of "type"
        time_now = f.readline().strip()
        simtime.append(time_now)
        
        while counter_b < NBIN_DIAG :
            matrix[counter_t, counter_b, :] = map(float,f.readline().strip().split())
            counter_b = counter_b + 1

        f.readline()
        counter_t = counter_t+ 1
        counter_b = 0
    f.close()
    
    simtime = np.array(map(float,simtime))
    delta_t = simtime[1] - simtime[0]

    # =====================================================
    # Selecting data in a case where s position is given
    if fix == 's':
        # Locating the svalue location index
        if loadsp(case) == 3 or loadsp(case) == 2:
            s     = load_s0(case)
        sloc  = int(s/delta_s)
        
        # Setting units and label of t-data
        data_x  = simtime
        data_y  = matrix[:, sloc, diaglist[0] - 1]
        label_y = diaglist[2]
        
        if si == 1:
            label_x = label_latex_t(si)
            data_x  = data_x / norm(case,s)[2]
            data_y  = data_y * norm(case,s)[diaglist[1]]
        else:
            label_x = label_latex_t(si)
            
        # Averating in t
        deltax = data_x[1]-data_x[0]
        
        if size(tavrg)==1:
            t0   = tavrg
            tf   = data_x[size(data_x)-1]
        elif size(tavrg)==2:
            t0     = min(tavrg[0], tavrg[1])
            tf     = max(tavrg[0], tavrg[1])            
        if abs(tf-t0) > 2*deltax:
            t0_loc = int(t0/deltax)
            tf_loc = int(tf/deltax)
        print 'SI units      = ', si
        print 'Time interval = ', '(',format(t0),', ', format(tf),')'
        mvalue = mean(data_y[t0_loc:tf_loc+1])
        error  = std(data_y[t0_loc:tf_loc+1])
        
        fig01(data_x, data_y, label_x, label_y, bar=[t0,tf])
            
        return map(scifloat, [mvalue, error])
    # =====================================================        
    if fix == 't':
        tloc = time / delta_t
    # =====================================================
    if fix == 'none':
        data_x  = simtime
        data_y  = svec
        data_z  = matrix[:, :, diaglist[0] - 1]

        print data_x.shape, data_y.shape, data_z.shape

        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        X,Y = data_x, data_y
        Z   = data_z
        ax.plot_surface(X, Y, Z)
        ax.set_xlabel(r'$\phi_\mathrm{real}$')
        ax.set_ylabel(r'$\phi_\mathrm{im}$')
        ax.set_zlabel(r'$V(\phi)$')
        plt.show(block=False)


def fig01(data_x=[], data_y=[], xlabel='x', ylabel='y', bar=[0.0,0.0], \
          ls='r-', mean = 0.0, error=0.0, xrange=[0.0,0.0], yrange=[0.0,0.0], num=0,\
          label=[]):
    fig         = 'figure' + str(num)
    plot        = 'plot' + str(num) 
    fig         = figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot           = plt.subplot(1,1,1)
    plot.grid(color='grey', linestyle='-', linewidth=0.3, label=label)
    plot.plot(data_x,data_y,ls, label=label)
    plot.set_xlabel(xlabel)
    plot.set_ylabel(ylabel)
    plot.legend(loc='best',labelspacing=0.0)
    if xrange != [0.0,0.0] or yrange != [0.0,0.0]:
        plot.axis([xrange[0], xrange[1], yrange[0], yrange[1]])
        
    plot.ticklabel_format(style='sci', scilimits=(0,0))
    xmin, xmax, ymin, ymax = axis()
    plot.barh(ymin, bar[1]-bar[0], height=(ymax-ymin), \
               left=bar[0], facecolor='yellow', alpha=0.3)
    if bar[1] != 0.0:
        plot.set_xlim(0.0, bar[1])
    if mean != 0.0:
        plot.axhline(y=mean, linewidth=2, color='b')
    fig.show()


def fig02(data_x=[], data_y=[], xlabel='x', ylabel='y',\
          bar=[0.0,0.0], mean = 0.0, error=0.0, num=0):
    fig         = 'figure' + str(num)
    plot        = 'plot' + str(num) 
    fig         = figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot           = plt.subplot(1,1,1)
    plot.grid(color='grey', linestyle='-', linewidth=0.3)
    plot.errorbar(data_x,data_y, error, 0.0, 'o-',color='red',markersize=5)
    plot.set_xlabel(xlabel)
    plot.set_ylabel(ylabel)
    plot.ticklabel_format(style='sci', scilimits=(0,0))
    xmin, xmax, ymin, ymax = axis()
    
    plot.barh(ymin, bar[1]-bar[0], height=(ymax-ymin), \
               left=bar[0], facecolor='yellow', alpha=0.3)
    if mean != 0.0:
        plot.axhline(y=mean, linewidth=2, color='b')
    fig.show()


def plot2y(data_x='none', data_y1='none', data_y2='none', data_y3='none',\
          xlabel='x', ylabel='y', key1='key1', key2='key2', key3='key3',\
          num=0):
    fig         = 'figure' + str(num)
    plot        = 'plot' + str(num) 
    fig         = figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot           = plt.subplot(1,1,1)
    plot.grid(color='grey', linestyle='-', linewidth=0.3)
    plot.plot(data_x,data_y1, 'b-', label=key1, linewidth=3)
    plot.plot(data_x,data_y2, 'r--',label=key2, linewidth=3)
    
    if(data_y3)!='none':
        plot.plot(data_x,data_y3, color="#FF9900", linestyle='dashdot',\
                  label=key3, linewidth=3)
    
    plot.legend(loc=1,labelspacing=0.0)
    plot.set_xlabel(xlabel)
    plot.set_ylabel(ylabel)
    plot.ticklabel_format(style='sci', scilimits=(0,0))
    fig.show()

def fig03(data_x='none', data_y1='none', data_y2='none', data_y3='none',\
          data_y4='none',xlabel='x', ylabel='y', key1='', key2='', key3='',\
          key4='', num=0, epsname='none', ylog=0, xrange='none', filled=1,\
          yrange='none'):
    
#    fig = plt.figure()
#    ax = fig.add_subplot(111)
#    ax.set_xscale('log')
    
    fig         = 'figure' + str(num)
    plot        = 'plot' + str(num)
    
    fig         = figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot           = plt.subplot(1,1,1)
    plot.grid(color='grey', linestyle='-', linewidth=0.3)
    if ylog == 1:
        plot.set_yscale('log', nonposy='clip')
    elif ylog == 0:
        plot.ticklabel_format(style='sci', scilimits=(0,0))
    plot.plot(data_x,data_y1, 'b-', label=key1, linewidth=3)
    plot.plot(data_x,data_y2, 'r--',label=key2, linewidth=3)
    
    if(data_y3)!='none':
#        plot.plot(data_x,data_y3, color="#FF9900", linestyle='dashdot',\
#                  label=key3, linewidth=3)
        plot.plot(data_x,data_y3, 'b-',label=key3, linewidth=3)
    if(data_y4)!='none':
#        plot.plot(data_x,data_y4, color="#FF9900", linestyle='dashdot',\
#                  label=key3, linewidth=3)
        plot.plot(data_x,data_y4, 'r--',label=key4, linewidth=3)

#    plot.text(0.14, 1.2E-3, '$H^+$', fontsize=35)
#    plot.text(0.14, 1.2E-4, '$e^-$', fontsize=35)

#    plot.text(0.14, 6E-3, '$H^+$', fontsize=35)
#    plot.text(0.14, 5E-5, '$e^-$', fontsize=35)

#    plot.set_title('W7-X prog. 20160309.010, $t=0.320$ s.', fontsize=20)
    plot.legend(loc=0,labelspacing=0.0)
    plot.set_xlabel(xlabel)
    plot.set_ylabel(ylabel)

#    plot.fill_between(data_x, data_y1, data_y3, facecolor='blue', interpolate=True, alpha=0.35)
#    plot.fill_between(data_x, data_y2, data_y4, facecolor='red', interpolate=True, alpha=0.35)
    
    if xrange != 'none':
        plot.set_xlim(xrange)

    if yrange != 'none':
        plot.set_ylim(yrange)
        
    if epsname != 'none':
        fig.tight_layout(pad=0.15, h_pad=0, w_pad=0)
        savefig(epsname)
        
    fig.show()
    
def norm(case, svalue = 0.0):
    # This function provides the normalization values
    # for the following quantities:
    #
    # distance      : rstar      [m]
    # B             : bstar      [T]
    # frequency     : omegastar  [s^{-1}]
    # velocity      : vstar      [m^{-1}]
    # temperature   : tstarev    [eV]
    # temperature   : tstarj     [J]
    # density       : nstar      [m^{-3}]
    # Electric field: efstar     [N/C]
    # Potential     : phistar    [V]
    # PDF           : fstar      [parts m^{-6}s^{3}]
    # Phase Sp. Vol : psvol      [m^{6}s^{-3}]
    # Vector pot.   : astar      [m T]
    # Current dens  : jstar      [A m^{-2}]
    # pflux dens    : pfdenss    [parts m^{-3}s^{-1}]
    # pflux dens    : pfdensr    [parts m^{-2}s^{-1}]
    # pflux         : pflux      [parts s^{-1}]
    import physcon as pc
    
    datafile = runsdir() + case + '/pars.dat'
    myfile       = open(datafile)
    content      = myfile.read()
    myfile.close()

    # Auxiliary constants and other magnitudes
    qe        = pc.e
    mp        = pc.m_p
    kev2ev    = 1000.
    sfactor   = read_npars(case)[8]
    if loadsp(case) == 2 or loadsp(case) == 3:
        svalue = load_s0(case)
    a         = rmin(case)[0]
    prof      = prof_values(case, svalue)
        
    rstar     = float(content.split("r* [m]")[1].split("\n")[0].split("=")[1])
    bstar     = float(content.split("B* [T]")[1].split("\n")[0].split("=")[1])
    omegastar = float(content.split("Omega* [Hz]")[1].split("\n")[0].split("=")[1])
    vstar     = float(content.split("v* [m s-1]")[1].split("\n")[0].split("=")[1])    
    tstarev   = float(content.split("T* [keV]")[1].split("\n")[0].split("=")[1]) * kev2ev
    tstarj    = tstarev * qe
    nstar     = float(content.split("n* [e19m-3]")[1].split("\n")[0].split("=")[1])
    efstar    = float(content.split("efield* [N/C]")[1].split("\n")[0].split("=")[1])
    phistar   = efstar * rstar
    fstar     = nstar / (vstar**3.)
    vpot      = rstar * bstar
    jstar     = qe * nstar * vstar  
    # Particle flux normalization
    pfdenss   = vstar*nstar*(1.0/rstar)
    pfdensr   = vstar*nstar*(1.0/rstar)*(a/2./sqrt(svalue))
    pflux     = vstar*nstar*(rstar**2.)*sfactor
    # Heat flux normalization
    efdenss   = mp*nstar*(vstar**3.)*(1.0/rstar)
    efdensr   = mp*nstar*(vstar**3.)*(1.0/rstar)*(a/2./sqrt(svalue))
    # Parallel current
    pcurr     = qe*nstar*vstar*bstar
    
    norm = [rstar,bstar,omegastar,vstar,tstarev,tstarj,nstar,\
           efstar, phistar, fstar, vpot, jstar, pfdenss, pfdensr,\
           pflux, efdenss, efdensr, pcurr]
    
    return  map(scifloat, norm)

# Format classes
def K2keV():
    return pc.k_B / pc.e / 1000.
def K2eV():
    return pc.k_B / pc.e
def norm2(case='none'):
    # Function that reads the normalization values from the norm.dat file
    # (necessary for neocl=0 runs, since not pars.dat is produced there)
    datafile = runsdir() + case + '/norm.dat'
    norm     = loadtxt(datafile)
    # Sorted as: B*, T* [K], rho*, Omega*, v*, phi*, efield*, afield*, n*, rhfs
    return norm

def label_latex_t(si=1):

    if si == 1:
        lab_1 = '$t\ [s]$'
    else:
        lab_1 = '$t\ [\Omega_{*}]$'
    return lab_1

def label_latex_pf(species='i', si = 1):

    if si == 1:
        lab_1 = '$\left<\Gamma_{'+species+'}\cdot\\nabla s\\right>\ [\\mathrm{parts\ } m^{-3}s^{-1}]$'
        lab_2 = '$\left<\Gamma_{'+species+'}\cdot\\nabla r\\right>\ [\\mathrm{parts\ } m^{-2}s^{-1}]$'
        lab_3 = '$F_{'+species+'}\ [\mathrm{parts\ } s^{-1}]$'
    else:
        lab_1 = '$\left<\Gamma_{'+species+'}\cdot\\nabla s\\right>\ [n_{*}v_{*}r_{*}^{-1}]$'
        lab_2 = '$\left<\Gamma_{'+species+'}\cdot\\nabla r\\right>\ [n_{*}v_{*}r_{*}^{-1}(a/2./\\sqrt(s)]$'
        lab_3 = '$F_{'+species+'}\ [n_{*}v_{*}r_{*}^{2}]$'     
        
    return lab_1, lab_2, lab_3

def label_latex_ef(species='i', si = 1):

    if si == 1:
        lab_1 = '$\left<\\mathbf{Q}_{'+species+'}\cdot\\nabla s\\right>\ [W m^{-3}]$'
        lab_2 = '$\left<\\mathbf{Q}_{'+species+'}\cdot\\nabla r\\right>\ [W m^{-2}]$'
    else:
        lab_1 = '$\left<\\mathbf{Q}_{'+species+'}\cdot\\nabla s\\right>\ [m_{p}*n_{*}v_{*}^{3}r_{*}^{-1}]$'
        lab_2 = '$\left<\\mathbf{Q}_{'+species+'}\cdot\\nabla r\\right>\ [m_{p}*n_{*}v_{*}^{3}r_{*}^{-1}(a/2./\\sqrt(s)]$'
        
    return lab_1, lab_2

class scifloat(float):
    def __repr__(self):
        return "%0.3e" % self
class float63(float):
    def __repr__(self):
        return "%6.3f" % self 
                                                  
    

def flsurf(case, species=0, kinpar=0.5, nvth=1.0, fsl='r', all=0, get='None', bing=0, TS=0,\
           m=1, z=1, saveeps=0, out='none', write='none'):
    # This function, reads the file ./flsurf_phi.dat present
    # on the directory of a certain case
    # and eturn the averaged potential between two
    # times (time_ini, time_end).
    #
    # kinpar : portion of thermal kinetic energy related to vpar
    
    phi_file =  runsdir() + case + '/flsurf_equil.dat'
    bin_data = open(phi_file, 'rb')
    
    # The following indeces specify the desired 2D plot
    RCYL_R, RCYL_Z, RCYL_PHI, RPEST_CHI, BMOD,\
    VGRB_S, VGRB_CHI, VGRB_PHI, DIVB, BROTB,\
    BS, BCHI, BPHI, SQRTG, PHI1,\
    EANG_CHI, EANG_PHI, VEXB_CHI, VEXB_PHI, VEXB_ANG_S,\
    VEXB_ANG_CHI, VEXB_ANG_PHI = arange(0,22)

    
    varnames = ['rcyl_r', 'rcyl_z', 'rcyl_phi', 'rpest_chi', 'bmod',\
              'vgrb_s', 'vgrb_chi', 'vgrb_phi', 'divb', 'brotb',\
              'bs', 'bchi', 'bphi, sqrt', 'phi1',\
              'eang_chi', 'eang_phi', 'vexb_chi', 'vexb_phi', 'vexb_ang_s',\
              'vexb_ang_chi', 'vexb_ang_phi']

#    from sympy.plotting import plot3d_parametric_surface
        
    # The file is read.
    # nchi and nphi below define the grid size for the estimation of the equil
    # quantities and related magnitudes computed in dump_fluxsurface_equil.
    # They are not necessarily equal to the nchi, nphi value of the input.
    #
    rb_value(bin_data,'1i')
    vernum        = rb_value(bin_data,'1d'); rb_value(bin_data)
    cpx_ver       = rb_value(bin_data,'1i'); rb_value(bin_data)
    elmag         = rb_value(bin_data,'1i')
    neo_eang      = rb_value(bin_data,'1i'); rb_value(bin_data)
    nchi          = rb_value(bin_data,'1i')
    nphi          = rb_value(bin_data,'1i')
    print 'estamos', vernum, nchi, nphi
    nfp           = rb_value(bin_data,'1i'); rb_value(bin_data)
    rhfs          = rb_value(bin_data,'1d')
    svalue        = rb_value(bin_data,'1d'); rb_value(bin_data)
    qsdms         = rb_value(bin_data, '3' + 'd'); rb_value(bin_data)
    msdqs         = rb_value(bin_data, '3' + 'd'); rb_value(bin_data)
    msdmp         = rb_value(bin_data, '3' + 'd'); rb_value(bin_data)
    equil_t       = rb_value(bin_data, '3' + 'd'); rb_value(bin_data)
    rcyl_r        = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    rcyl_z        = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)    
    rcyl_phi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    rcyl_chi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
#    bin_vol_2d    = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    bmod          = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    bs            = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    bchi          = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    bphi          = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    divb          = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    sqrtg         = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    nablas2       = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    vgrb_s        = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)   
    vgrb_chi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)      
    vgrb_phi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data) 
    vcur_s        = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)   
    vcur_chi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)      
    vcur_phi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    vexb_chi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
    vexb_phi      = rb_value(bin_data,str(nchi*nphi) + 'd')




    

    rcyl_r        = reshape(rcyl_r, (nphi,nchi))
    rcyl_z        = reshape(rcyl_z, (nphi,nchi))
    rcyl_phi      = reshape(rcyl_phi, (nphi,nchi))
    rcyl_chi      = reshape(rcyl_chi, (nphi,nchi))
#    bin_vol_2d    = reshape(bin_vol_2d, (nphi,nchi)) 
    bmod          = reshape(bmod, (nphi,nchi))
    bs            = reshape(bs, (nphi,nchi))
    bchi          = reshape(bchi, (nphi,nchi))
    bphi          = reshape(bphi, (nphi,nchi))
    divb          = reshape(divb, (nphi,nchi))
    nablas2       = reshape(nablas2, (nphi,nchi))
    sqrtg         = reshape(sqrtg, (nphi,nchi))
    vgrb_s        = reshape(vgrb_s, (nphi,nchi))
    vgrb_chi      = reshape(vgrb_chi, (nphi,nchi))
    vgrb_phi      = reshape(vgrb_phi, (nphi,nchi))
    vcur_s        = reshape(vcur_s, (nphi,nchi))
    vcur_chi      = reshape(vcur_chi, (nphi,nchi))
    vcur_phi      = reshape(vcur_phi, (nphi,nchi))
    vexb_chi      = reshape(vexb_chi, (nphi,nchi))
    vexb_phi      = reshape(vexb_phi, (nphi,nchi))

    print "======================================"
    print "r , z, chi , phi  = ", rcyl_r[0,0], rcyl_z[0,0], rcyl_chi[0,0], rcyl_phi[0,0]
    print "bs, bchi, bphi    = ", bs[0,0], bchi[0,0], bphi[0,0]
    print "g^{1/2}           = ", sqrtg[0,0]
    print "======================================"
    
    if neo_eang == 1:
        rb_value(bin_data)
        phi1          = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
        Eang_chi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)      
        Eang_phi      = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)    
        vexbang_s     = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
        vexbang_chi   = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
        vexband_phi   = rb_value(bin_data,str(nchi*nphi) + 'd'); rb_value(bin_data)
        aphi1         = rb_value(bin_data,str(nchi*nphi) + 'd')
        
        phi1          = reshape(phi1, (nphi,nchi))
        Eang_chi      = reshape(Eang_chi, (nphi,nchi))
        Eang_phi      = reshape(Eang_phi, (nphi,nchi))
        vexbang_s     = reshape(vexbang_s, (nphi,nchi))
        vexbang_chi   = reshape(vexbang_chi, (nphi,nchi))
        vexband_phi   = reshape(vexband_phi, (nphi,nchi))
        aphi1         = reshape(aphi1, (nphi,nchi))


    rb_value(bin_data,'1i')
    # 
    # nabla s = ds/dr nabla r ; ds/dr = 2*sqrt(s)/a 
    if fsl=='r':
        a       = rmin(case)[0]; 
        dsdfsl  = 2 * sqrt(svalue) / a
        fsl     = sqrt(svalue) * a
    elif fsl=='s':
        dsdfsl = 1.0
        fslval  = svalue
    elif fsl=='rho':
        fslfact = 2 * sqrt(svalue)
        fslval  = sqrt(svalue)

    # Adding the missing factors to the gradB and curvature drifts

    if m!=1:
        mass = m
        moz  = m/z
    else:
        mass = msdmp[species]
        moz  = msdqs[species]

    #mass =1
    #moz=1
    #
    vth2      = 2 * equil_t[species] / mass
    vthsi     = sqrt(vth2) * norm(case)[3]
    vpar2     = kinpar        * vth2  * (nvth**2.)
    vper2     = (1. - kinpar) * vth2  * (nvth**2.)


    
    fac_vgrb  = moz * 0.5 * vper2 / bmod
    fac_vcur  = moz * vpar2       / bmod
    nablar    = sqrt(nablas2) / norm2(case)[2] / dsdfsl
    vgrb_s    = fac_vgrb * vgrb_s   * norm(case)[3] * dsdfsl / norm(case)[0]
    vgrb_chi  = fac_vgrb * vgrb_chi * norm(case)[3]
    vgrb_phi  = fac_vgrb * vgrb_phi * norm(case)[3]
    vcur_s    = fac_vcur * vcur_s   * norm(case)[3] * dsdfsl / norm(case)[0]
    vcur_chi  = fac_vcur * vcur_chi * norm(case)[3]
    vcur_phi  = fac_vcur * vcur_phi * norm(case)[3]
    am        = -(vper2 / 2.) * divb * (norm(case)[3]**2) / norm(case)[0]
    
    # Providing SI units
    # norm = [rstar,bstar,omegastar,vstar,tstarev,tstarj,nstar,\
    #         efstar, phistar, fstar, vpot, jstar, pfdenss, pfdensr,\
    #         pflux, efdenss, efdensr, pcurr]

    
#    bin_vol_2d= bin_vol_2d * (norm(case)[0]**3)          # in m^3
    bmod      = bmod     * norm(case)[1]
    bs        = bs       * norm(case)[1] / norm(case)[0] # B.grads
    bchi      = bchi     * norm(case)[1] / norm(case)[0] # B.gradchi
    bphi      = bphi     * norm(case)[1] / norm(case)[0] # B.gradphi
    rcyl_r    = rcyl_r   * norm(case)[0]
    rcyl_z    = rcyl_z   * norm(case)[0]
    vexb_chi  = vexb_chi * norm(case)[3]
    vexb_phi  = vexb_phi * norm(case)[3]

#    print 'Sum of all bin volumes: ', bin_vol_2d.sum(), ' m^3'
  
    if neo_eang == 1:
        phi1       = phi1      * norm(case)[8]
        vexbang_s  = vexbang_s * norm(case)[3] * dsdfsl / norm(case)[0]

        fact_aphi1 = - 1./moz
        
        aphi1star  = (pc.e/pc.m_p) * norm(case)[8] / norm(case)[0]
        aphi1      = aphi1     * fact_aphi1 * aphi1star


    if get == 'drifts':
        if neo_eang==1:
            return vgrb_s + vcur_s + vexbang_s
        elif neo_eang==0:
            return vgrb_s + vcur_s
    elif get == 'mirror':
        if neo_eang==1:
            return aphi1+am
        elif neo_eang==0:
            return am
    
    # Theta and phi arrays
    phi_arr = zeros(nphi)
    chi_arr = zeros(nchi)
    for j in range(0,nphi):
        phi_arr[j]= 2*pi*j/(nfp*(nphi))
    for j in range(0,nchi):
        chi_arr[j]=2*pi*j/(nchi)


    if write == 'JL':
        out_file  = './nablar_r_3cols.dat'
        f           = open(out_file,'w')
        f.write('# |nabla r| from run: ' + case + '\n')
        f.write('# svalue            = ' + str(nchi)    + '\n')
        f.write('# ntheta            = ' + str(nchi)    + '\n')
        f.write('# nzeta             = ' + str(nphi)    + '\n')
        f.write('# nfp               = ' + str(nfp)     + '\n')
        f.write('# zeta\t theta\t |nabla r|\n')
        
        for iphi in arange(0, nphi):
            for ichi in arange(0, nchi):
                f.write(str(format5(phi_arr[iphi]))+'\t'+\
                        str(format5(chi_arr[ichi]))+'\t'+\
                        str(format5(nablar[iphi, ichi]))+'\n')
                        

    if bing == 1:
        dphi  = phi_arr[1]-phi_arr[0]
        phi_D = 0.382000E+02*2*pi/360.
        phi_B = (0.195000E+03-180)*2*pi/360.
        loc_D = int(phi_D/dphi)
        loc_B = int(phi_B/dphi)
        R_D   = 0.134000E+01
        R_B   = 0.163191E+01
    
        R = (rhfs*norm(case)[0]+rcyl_r)

        

        R_D_vec = R[loc_D,:]
        R_B_vec = R[loc_B,:]
        Z_D_vec = rcyl_z[loc_D,:]
        Z_B_vec = rcyl_z[loc_B,:]
        chi_D_vec = rcyl_chi[loc_D,:]
        chi_B_vec = rcyl_chi[loc_B,:]
        

        fig01(R_B_vec,Z_B_vec, ls='r-o', label='B', xrange=[1.0, 2.0], yrange=[0, 1.0],\
              xlabel = 'R [m]', ylabel='z [m]')
        
        fig01(R_B_vec-R_B, chi_B_vec, ls='r-o', label='B')

        fig01(R_D_vec,Z_D_vec, ls='b-o', label='D', xrange=[1.0, 2.0], yrange=[0, 1.0],\
              xlabel = 'R [m]', ylabel='z [m]')
        
        fig01(R_D_vec-R_D, chi_D_vec, ls='b-o', label='D')        


        
        fig.show()

        
    if TS == 1:
        dphi  = phi_arr[1]-phi_arr[0]    
        phi_TS= 14.5*2*pi/360.
        alpha = 17  *2*pi/360.

        t0     =  -0.3
        tf     =  0.5
        nt     =  100
        deltat = (tf-t0)/(nt-1)
        tvec   =  arange(t0 , tf , deltat)
        
        loc_TS = int(phi_TS/dphi)
    
        r_TS_t = 0.5923
        z_TS_t = 0.4202
        r_TS_b = 0.4913
        z_TS_b = 0.0898

        
        r_b  =  0.1257 + sin(alpha)*tvec + 0.4
        z_b  = -0.1976 + cos(alpha)*tvec + 0.4 
        r_TS = rcyl_r[loc_TS,:]
        z_TS = rcyl_z[loc_TS,:]
        chi_TS = rcyl_chi[loc_TS,:]
        
        plot(r_TS,  z_TS, r_b, z_b)
        fig01(chi_TS, r_TS - r_TS_t)
        
#        axis([-1, 1, 0, 1])
        show()

    # Color map of bin_vol_2d
    if saveeps==1:
        epsname01 = 'radial_drifts'
        epsname02 = 'trapping'
        epsname03 = 'magfield'
        epsname04 = 'phi1field'
        epsname05 = 'nablar'
    else:
        epsname01  = 'None'
        epsname02  = 'None'
        epsname03  = 'None'
        epsname04  = 'None'        
        epsname05  = 'None'
        
    if out == 'R':
        return rhfs*norm(case)[0]+rcyl_r
    elif out == 'Z':
        return rcyl_z

    print nablar
    # Color map of B
    plmap(xdata=phi_arr, ydata=chi_arr,zdata=bmod.transpose(),\
          xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$B(\\theta,\phi)$ [T]',num=1,
          epsname=epsname03)
    
    plmap(xdata=phi_arr, ydata=chi_arr,zdata=nablar.transpose(),\
          xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$\\nabla r(\\theta,\phi)$',num=1,
          epsname=epsname05)
    
    if all == 1:
        # Color map of bin_vol_2d
#        plmap(xdata=phi_arr, ydata=chi_arr,zdata=bin_vol_2d.transpose()*1e6,\
#              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$V_{bins}$ [cm$^3$]',num=1)
        # Color map of v_nablaB
        plmap(xdata=phi_arr, ydata=chi_arr,zdata=vgrb_s.transpose(),\
              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]',\
              zlabel='$\\mathbf{v}_{\\nabla B}\cdot\\nabla r $ [m/s]',\
              cmap='gist_heat', num=1)
        # Color map of v_curv
        plmap(xdata=phi_arr, ydata=chi_arr,zdata=vcur_s.transpose(),\
              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]',\
              zlabel='$\\mathbf{v}_{\\kappa}\cdot\\nabla r $ [m/s]',\
              cmap='gist_heat', num=1, contourf=0)
        
    # Color map of v_d
    plmap(xdata=phi_arr, ydata=chi_arr,zdata=(vgrb_s.transpose()+vcur_s.transpose()),\
          xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$\\mathbf{v}_{d}\cdot\\nabla r $ [m/s]',\
          cmap='gist_heat', num=1, contourf=0)

    # Color map of am
    plmap(xdata=phi_arr, ydata=chi_arr,zdata=am.transpose(),\
          xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$-\\mu \\mathbf{b}\\cdot\\nabla B$ [m/s$^2$]',\
          cmap='bone', num=1, contourf=0)
    
    if neo_eang==1:
        # Color map of Phi1
        plmap(xdata=phi_arr, ydata=chi_arr,zdata=phi1.transpose(),\
              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$\\Phi_1(\\theta,\phi)$ [V]',num=1,
              epsname=epsname04)
        if all == 1:
            plmap(xdata=phi_arr, ydata=chi_arr\
                  ,zdata=prof_values(case)[12]*exp(-phi1.transpose()*6/prof_values(case)[6]/1000),\
                  xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$Boltzmann$ [V]',num=1)        
        # Color map of v_E1    
        plmap(xdata=phi_arr, ydata=chi_arr,zdata=vexbang_s.transpose(),\
              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]',zlabel='$\\mathbf{v}_{E1}\cdot\\nabla r $ [m/s]',\
              cmap='gist_heat', num=1)
        # Color map of v_d+v_E1
        plmap(xdata=phi_arr, ydata=chi_arr,\
              zdata=(vgrb_s.transpose()+vcur_s.transpose()+vexbang_s.transpose()),\
              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]',\
              zlabel='$\\mathbf{v}_{d}+\\mathbf{v}_{E1})\cdot\\nabla r $ [m/s]',num=1,\
              cmap='gist_heat', contourf=0, epsname=epsname01)
        # Color map of aphi1
        plmap(xdata=phi_arr, ydata=chi_arr,zdata=aphi1.transpose(),xlabel='$\phi$ [rad]',\
              ylabel='$\\theta$ [rad]', zlabel='$-(q/m)\\mathbf{b}\\cdot\\nabla \\Phi_1$ [m/s$^2$]',\
              cmap='bone', num=1, contourf=0)
        
        # Color map of am+aphi1
        zlabel = '$-(q/m)\\mathbf{b}\\cdot\\nabla \\Phi_1-\\mu \\mathbf{b}\\cdot\\nabla B$ [m s$^{-2}$]'
        plmap(xdata=phi_arr, ydata=chi_arr,zdata=aphi1.transpose()+am.transpose(),xlabel='$\phi$ [rad]',\
              ylabel='$\\theta$ [rad]', zlabel=zlabel,\
              cmap='bone', num=1, contourf=0, epsname=epsname02)       
    
###############################################################################
##################### PLOTING FUNCTIONS #######################################
###############################################################################
def plmap(xdata=[], ydata=[], zdata=[], xlabel='x', ylabel='y', zlabel='z', ctics=0, num=0,\
          contour=1, contourf=0, cmap='jet', vfield=0, vxdata=[], vydata=[], cont2='None',\
          epsname='None', crange='none'):
    # Remember:
    # cmap scales: RdBu_r (Red Blue), BdBu_r (Blue scale to white), jet (common)
    fig         = 'figure' + str(num)
    plot        = 'plot' + str(num) 
    fig         = figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot        = plt.subplot(1,1,1)
    plot.set_ylabel(ylabel)
    plot.set_xlabel(xlabel)
    if contourf==1:
        cax = plot.contourf(xdata, ydata, zdata, alpha=1, cmap=cmap)
    else:
        if crange == 'none':
            cax = plot.pcolor(xdata, ydata, zdata, cmap=cmap)
        else:
            cax = plot.pcolor(xdata, ydata, zdata, vmin=crange[0], vmax=crange[1], cmap=cmap)
        cbar = colorbar(cax)
        cbar.formatter.set_powerlimits((0,0))
        cbar.formatter.set_scientific(True)
        cbar.update_ticks()
        cbar.set_label(zlabel)
        
        if vfield == 1:
            speed = sqrt(vxdata**2 + vydata**2)
            lw = 2.*speed/speed.max()
            plot.streamplot(xdata, ydata, vxdata, vydata,\
                                   density=[2,2], color='k', linewidth=lw)
    if cont2!='None':
        CS2 = plot.contour(xdata, ydata, cont2, 12, colors ='black', linewidths = 1.5)
    if contour==1:
        CS2 = plot.contour(xdata, ydata, zdata, levels=[-10, -5, -0.1, 0.0, 0.1, 1.0, 5, 10], colors ='black', linewidths = 1.5)
        
        if(ctics==1):
            plot.clabel(CS2, inline=1, fmt='%3.1f', fontsize=14)

    plot.axis([xdata[0], xdata[size(xdata)-1], ydata[0], ydata[size(ydata)-1]])
    fig.show()

    if epsname != 'None':
        fig.tight_layout(pad=0.15, h_pad=0, w_pad=0)
        fig.savefig(plotdir()+ epsname + '.eps')
        print plotdir()+ epsname + '.eps'
        
def plmapvec(xdata=[], ydata=[], vxdata=[], vydata=[], vzdata=[],\
             xlabel='x', ylabel='y', zlabel='z', ctics=0, num=0):

    fig         = 'figure' + str(num)
    plot        = 'plot' + str(num) 
    fig         = figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot        = plt.subplot(1,1,1)
    plot.set_ylabel(ylabel)
    plot.set_xlabel(xlabel)
    cax    = plot.streamplot(xdata, ydata, vxdata, vydata)
    title(zlabel)
    plot.axis([0, xdata[size(xdata)-1], 0, ydata[size(ydata)-1]])
    fig.show()



def dandv(datafile='none', equil='lhd2', case='I.A', species='C6', nspl=50):
    #
    # Function for the analysis of data generated with EUTERPE
    # for the obtention of D and V for the different cases
    # considered in the work on the influence of Phi1 on Z fluxes.
    #
    # 6 parameters enter in the analysis
    #
    # Equilibrium:   lhd2, w7x2, tj20
    # Case:          I.A, I.B, ...
    # Species:       C6, Fe20, W40
    # Phi choice:    0, 1 (w/o and w/ Phi1)
    # load_s0:       0.2, 0.4, 0.6, 0.8
    # n'z:           Z density gradient (considered in the x-axis variable)

    import numpy as np
    nrows=shape(genfromtxt(datafile, dtype=None))
    ncols=20
    
    data_str   = genfromtxt(datafile, usecols=(0,1,2), dtype=str)
    data_int   = genfromtxt(datafile, usecols=(3),     dtype=int)
    data_flo   = genfromtxt(datafile, usecols=(4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19), dtype=float)

    nrows      = shape(data_flo)[0]

    equils   = ['lhd2', 'w7x2', 'tj20']

    if 'lhd2' in equil:
        cases  =['I.A', 'I.B', 'I.C', 'II.A', 'II.B', 'II.C']
        species=['C6', 'Fe20', 'W40']
        splab  =['C$^{6+}$', 'Fe$^{20+}$', 'W$^{40+}$']
        a      = rmin('lhd2')[0]
        equ    = 'LHD'
    elif 'w7x2' in equil:
        cases  =['I.A', 'I.B', 'I.C']
        species=['C6', 'W40']
        splab  =['C$^{6+}$', 'W$^{40+}$']
        a      = rmin('w7x2')[0]
        equ    = 'W7-X'
    elif 'tj20' in equil:
        cases  =['Low dens.', 'High dens.']
        species=['C6', 'Fe20']
        splab  =['C$^{6+}$', 'Fe$^{20+}$']
        a      = rmin('w7x2')[0]
        equ    = 'TJ-II'

    print a
    phis    = [0,1]
    svalues = [4.68700e-02, 1.71875e-01, 3.59370e-01, 6.40625e-01]

    ncases   = size(cases)
    nspecies = size(species)
    nphis    = size(phis)
    ns       = size(svalues)
    ngrad    = 3

    grad = zeros((ncases, nspecies, nphis, ns, ngrad))
    dens = zeros((ncases, nspecies, nphis, ns, ngrad))
    flux = zeros((ncases, nspecies, nphis, ns, ngrad))
    err  = zeros((ncases, nspecies, nphis, ns, ngrad))

    x    = zeros((ncases, nspecies, nphis, ns, ngrad))
    y    = zeros((ncases, nspecies, nphis, ns, ngrad))
    yerr = zeros((ncases, nspecies, nphis, ns, ngrad))


    
    for icase in range (0, ncases):
        for ispecies in range (0, nspecies):
            for iphi in range (0, nphis):
                for isvalue in range (0, ns):
                    ingrad = 0
                    for irhow in range(0, nrows):
                        if [icase, ispecies, iphi, isvalue] == \
                               [cases.index(data_str[irhow, 1]),\
                                species.index(data_str[irhow, 2]),\
                                phis.index(data_int[irhow]),\
                                svalues.index(data_flo[irhow,1])]:
                            grad[icase, ispecies, iphi, isvalue, ingrad]  = data_flo[irhow, 12]
                            dens[icase, ispecies, iphi, isvalue, ingrad]  = data_flo[irhow, 13]
                            flux[icase, ispecies, iphi, isvalue, ingrad]  = data_flo[irhow, 14]
                            err[icase, ispecies, iphi, isvalue, ingrad]   = data_flo[irhow, 15]
                            
                            x[icase, ispecies, iphi, isvalue, ingrad]=\
                                     grad[icase, ispecies, iphi, isvalue, ingrad]*2.*sqrt(data_flo[irhow, 1])/a
                            
                            y[icase, ispecies, iphi, isvalue, ingrad]=\
                                     flux[icase, ispecies, iphi, isvalue, ingrad]/dens[icase, ispecies,\
                                                                                       iphi, isvalue, ingrad]
                            yerr[icase, ispecies, iphi, isvalue, ingrad]=\
                                        err[icase, ispecies, iphi, isvalue, ingrad]/dens[icase, ispecies,\
                                                                                         iphi, isvalue, ingrad]
                            
                            ingrad = ingrad + 1
                            
    iequil = equils.index(equil)


    data   = zeros((2,4,5))
    yspl_V = zeros((2,nspl))
    yspl_D = zeros((2,nspl))
    
    for icase in range (0, ncases):
        for ispecies in range (0, nspecies):
            for iphi in range (0, nphis):
                


                file_name= 'dandv_' + equils[iequil]+ '_'+ cases[icase] +\
                           '_' + species[ispecies] + '_' + str(phis[iphi]) + '.dat'
                fig_name= 'dandv_' + equils[iequil]+ '_'+ cases[icase] +\
                           '_' + species[ispecies] + '_' + str(phis[iphi])
                eps_name= 'dandv_' + equils[iequil]+ '_'+ cases[icase] +\
                           '_' + species[ispecies] + '_' + str(phis[iphi]) + '.eps'
                
                f = open(file_name, 'w')
                f.write('# Processed file: ' + datafile + '\n')
                f.write('# Equil: ' + equils[iequil] + '\n')
                f.write('# Cases: ' + cases[icase] + '\n')
                f.write('# Species: ' + species[ispecies] + '\n')
                f.write('# Phi1 choice: ' + str(phis[iphi]) + '\n')
                f.write('\n')
                f.write('# r/a \t D[m^2/s]\t Derr \t V[m/s] \t Verr \n')

                if any(x!=0 for x in y[icase,ispecies,iphi,isvalue,:]):
                    
                    for isvalue in range (0,ns):
                        
                        xx = x[icase,ispecies,iphi,isvalue,:]
                        yy = y[icase,ispecies,iphi,isvalue,:]
                        yyerr=y[icase,ispecies,iphi,isvalue,:]
                        
                        out  = optimize.curve_fit(func, xx, yy, p0=None, sigma=yyerr)
                        D  = out[0][0]
                        V  = out[0][1]
                        cov  = out[1] 
                        Derr = sqrt(np.diag(cov))[0]
                        Verr = sqrt(np.diag(cov))[1]
                        
                        print 'D = ', format6(D),' +/- ', format6(Derr), ' ; '\
                              'V = ', format6(V),' +/- ', format6(Verr)
                        
                        data[iphi, isvalue, :]=[sqrt(svalues[isvalue]), D, Derr, V, Verr]
                        
                        f.write(str(sqrt(svalues[isvalue])) + '\t' + \
                                str(D) + '\t' + str(Derr) + '\t' + str(V) + '\t' + str(Verr)+'\n')
                        
                        f.close

                # Construction of the spline fitting for V(r/a) and D(r/a)
                xspl           = np.linspace(sqrt(svalues[0]), sqrt(svalues[3]), nspl)
                spl_D          = UnivariateSpline(data[iphi, :,0], data[iphi, :,1])
                yspl_D[iphi,:] = spl_D(xspl)
                spl_V          = UnivariateSpline(data[iphi, :,0], data[iphi, :,3])
                yspl_V[iphi,:] = spl_V(xspl)


                # "o"	circle (C6+)
                # "s"   squares (Fe20+)
                # "^"   Triangles up (W40+)
                
            fig = plt.figure(num=None, figsize = (8.0,8.0), dpi = 100)
            subplots_adjust(left=0.15, bottom=0.15, right=0.85, top=0.85,\
                            wspace=0.00, hspace=0.00)
            ax= fig.add_subplot(111)
            ax.plot(xspl, yspl_V[0,:], linestyle='-', color='red', linewidth=2.5)
            ax.plot(xspl, yspl_V[1,:], linestyle='-', color='red', linewidth=2.5)
            ax.errorbar(data[0, :,0], data[0, :, 3], yerr=data[0, :,4], fmt='o', color='red',\
                        markersize=10, mfc = 'white', markeredgewidth=2.5, mec='red', label="$V$ w/o $\Phi_1$")
            ax.errorbar(data[1, :,0], data[1, :, 3], yerr=data[1, :,4], fmt='o', color='red' ,\
                        markersize=10, mfc = 'red', markeredgewidth=2.5, mec='red', label="$V$ w/  $\Phi_1$")
            
            ax2 = ax.twinx()
            ax2.plot(xspl, yspl_D[0,:], linestyle='--', color='blue', linewidth=2.5)
            ax2.plot(xspl, yspl_D[1,:], linestyle='--', color='blue', linewidth=2.5)
            ax2.errorbar(data[0, :,0], data[0, :, 1], yerr=data[0, :,2], fmt='s', color='blue',\
                         markersize=10, mfc = 'white', markeredgewidth=2.5, mec='blue', label="$D$ w/o $\Phi_1$")
            ax2.errorbar(data[1, :,0], data[1, :, 1], yerr=data[1, :,2], fmt='s', color='blue' ,\
                         markersize=10, mfc = 'blue', markeredgewidth=2.5, mec='blue', label="$D$ w/  $\Phi_1$")
#            ax2.grid(color='grey', linestyle='--', linewidth=0.2)
            ax.set_xlabel("$r/a$")
            ax.set_ylabel("$V$ [m s$^{-1}$] ")
            ax2.set_ylabel("$D$ [m$^2$ s$^{-1}$] ")
            ax.set_title(equ + ' case ' + cases[icase] + ' for ' + splab[ispecies])
            ax.set_xlim([0, 1])
            ax.yaxis.set_minor_locator(AutoMinorLocator(10))
            ax2.yaxis.set_minor_locator(AutoMinorLocator(10))
            ax.xaxis.set_minor_locator(AutoMinorLocator(10))
            ax.legend(loc=3, prop={'size':18})
            ax2.legend(loc=1, prop={'size':18})
            plt.show(block=False)
            epsname= equil + '_' + cases[icase] + '_' + species[ispecies] + '.eps'
            fig.savefig(epsname, format='eps', dpi=1000)
            
            # data[0,:] corresponds to the first row of data
            # data[:,0] corresponds to the first column of data
            
            # We show the figures now and save them



    
#    plt.figure()   
#    plt.plot(data[:,0],data[:,1])
#    
#    plt.show()     
#    _ = raw_input("Press [enter] to continue.") # wait for input from the user
#    plt.close()    

                
def printcase(hpc='none', equil='none', num0=0, num1=1, format=4):


    for i in range(num0, num1+1):

        case_name = equil + '_' + str(i).zfill(format)
        path_name = hpc + '/' + equil + '_' + str(i).zfill(format)

        if qsde(path_name) == 6: sp='C6'
        if qsde(path_name) == 20: sp='Fe20'
        if qsde(path_name) == 40: sp='W40'



        
        print case_name, sp, neo_eang(path_name), format4(er(path_name, info=0)[0]),\
              format5(prof_values(path_name)[0]),\
              format5(prof_values(path_name)[1]),\
              format5(prof_values(path_name)[2]),\
              format5(prof_values(path_name)[3]),\
              format5(prof_values(path_name)[4]),\
              format5(prof_values(path_name)[5]),\
              format5(prof_values(path_name)[6]),\
              format5(prof_values(path_name)[7]),\
              format5(prof_values(path_name)[8]),\
              format5(prof_values(path_name)[9]),\
              format5(prof_values(path_name)[10]),\
              format5(prof_values(path_name)[11]),\
              format5(prof_values(path_name)[12])


def ppcfz(hpc='none', equil='none', case='I.A', species='C6', yrange=None, pos=3, nspl=100,\
          spl=1, runs='', sfincs=0):

    path = '/afs/ipp-garching.mpg.de/home/r/rjose/Trabajo/Results/2014_z_flux_with_phi1/non_mirror_rest/'
    plotdir = path + equil + '/plot/'
    labely = '$\left<\Gamma_{Z}\cdot\\nabla r\\right>/n_{0Z}\ [\\mathrm{m}\ \\mathrm{s}^{-1}]$'
    
    
    if 'lhd2' in equil:
        cases  =['A.I', 'A.II', 'A.III', 'B.I', 'B.II', 'B.III']
        sps    =['C6', 'Fe20', 'W40', 'Ne10']
        splab  =['C$^{6+}$', 'Fe$^{20+}$', 'W$^{40+}$', 'Ne$^{10+}$']
        fmtsp  =['o', 's', '^', 'd']
        colsp  =['black', 'red', 'blue', 'darkgreen']
        a      = rmin('lhd2')[0]
        equ    = 'LHD'
        
        data   = empty((size(cases),2,size(sps)), dtype='|S20')
        datasfincs = empty((size(cases),2,size(sps)), dtype='|S35')

        # [case, phi, z]
        data[0,0,0] = 'lhd2_695_698.dat'
        data[1,0,0] = 'lhd2_699_702.dat'
        data[2,0,0] = 'lhd2_703_706.dat'
        data[3,0,0] = 'lhd2_707_710.dat'
        data[4,0,0] = 'lhd2_711_714.dat'
        data[5,0,0] = 'lhd2_715_718.dat'
        # C6 LHD cases
        if runs == 'old':
            # These runs were performed with the wrong bfactor loaded
            data[0,1,0] = 'lhd2_671_674.dat'
            data[1,1,0] = 'lhd2_675_678.dat'
            data[2,1,0] = 'lhd2_679_682.dat'
            data[3,1,0] = 'lhd2_683_686.dat'
            data[4,1,0] = 'lhd2_687_690.dat'
            data[5,1,0] = 'lhd2_691_694.dat'
        else:
            # These runs were performed with the correct bfactor loaded
            data[0,1,0] = 'lhd2_831_834.dat'
            data[1,1,0] = 'lhd2_835_838.dat'
            data[2,1,0] = 'lhd2_839_842.dat'
            data[3,1,0] = 'lhd2_843_846.dat'
            data[4,1,0] = 'lhd2_847_850.dat'
            data[5,1,0] = 'lhd2_851_854.dat'
            #
            datasfincs[2,0,0] = 'lhd2_C6_A_III_wo_phi1_sfincs.dat'
            datasfincs[2,1,0] = 'lhd2_C6_A_III_w_phi1_sfincs.dat'
            
            
        data[0,0,1] = 'lhd2_719_722.dat'
        data[1,0,1] = 'lhd2_723_726.dat'
        data[2,0,1] = 'lhd2_727_730.dat'
        data[3,0,1] = 'lhd2_731_734.dat'
        data[4,0,1] = 'lhd2_735_738.dat'
        data[5,0,1] = 'lhd2_739_742.dat'
        
        if runs == 'old':
            data[0,1,1] = 'lhd2_743_746.dat'
            data[1,1,1] = 'lhd2_747_750.dat'
            data[2,1,1] = 'lhd2_751_754.dat'
            data[3,1,1] = 'lhd2_755_758.dat'
            data[4,1,1] = 'lhd2_759_762.dat'
            data[5,1,1] = 'lhd2_763_766.dat'
        else:
            data[0,1,1] = 'lhd2_855_858.dat'
            data[1,1,1] = 'lhd2_859_862.dat'
            data[2,1,1] = 'lhd2_863_867.dat'
            data[3,1,1] = 'lhd2_867_870.dat'
        #
        data[0,0,2] = 'lhd2_767_770.dat'
        data[1,0,2] = 'lhd2_771_774.dat'
        data[2,0,2] = 'lhd2_775_778.dat'
        data[3,0,2] = 'lhd2_779_782.dat'
        data[4,0,2] = 'lhd2_783_786.dat'
        data[5,0,2] = 'lhd2_787_790.dat'
        
        # W40 LHD cases
        if runs == 'old':
            data[0,1,2] = 'lhd2_791_794.dat'
            data[1,1,2] = 'lhd2_795_798.dat'
            data[2,1,2] = 'lhd2_799_802.dat'
            data[3,1,2] = 'lhd2_803_806.dat'
            data[4,1,2] = 'lhd2_807_810.dat'
            data[5,1,2] = 'lhd2_811_814.dat'
        else:
            data[0,1,2] = 'lhd2_883_886.dat'
            data[5,1,2] = 'lhd2_903_906.dat'
            
        # Ne10 LHD cases
        data[0,0,3] = 'lhd2_923_926.dat'
        data[0,1,3] = 'lhd2_927_930.dat'
        data[1,0,3] = 'lhd2_931_934.dat'
        data[1,1,3] = 'lhd2_935_938.dat'
        data[2,0,3] = 'lhd2_939_942.dat'
        data[2,1,3] = 'lhd2_943_946.dat'
        data[3,0,3] = 'lhd2_947_950.dat'
        data[3,1,3] = 'lhd2_951_954.dat'
        data[4,0,3] = 'lhd2_955_958.dat'
        data[4,1,3] = 'lhd2_959_962.dat'
        data[5,1,3] = 'lhd2_915_918.dat'
        data[5,0,3] = 'lhd2_919_922.dat'        
        
    elif 'w7x2' in equil:
        cases  =['I', 'II', 'III', 'IV', 'Off-axis']
        sps    =['C6', 'W40']
        splab  =['C$^{6+}$', 'W$^{40+}$']
        fmtsp  =['o', '^']
        colsp  =['black', 'blue']
        a      = rmin('w7x2')[0]
        equ    = 'W7-X'
        
        data = empty((size(cases),2,size(sps)), dtype='|S20')
        
        # [case, phi, z]
        data[0,0,0] = 'w7x2_077_080.dat'
        data[1,0,0] = 'w7x2_081_084.dat'
        data[2,0,0] = 'w7x2_085_088.dat'
        data[3,0,0] = 'w7x2_089_092.dat'
        data[4,0,0] = 'w7x2_145_148.dat'
        data[0,1,0] = 'w7x2_093_096.dat'
        data[1,1,0] = 'w7x2_097_100.dat'
        data[2,1,0] = 'w7x2_101_104.dat'
        data[3,1,0] = 'w7x2_105_108.dat'
        data[4,1,0] = 'w7x2_149_152.dat'
        #
        data[0,0,1] = 'w7x2_109_112.dat'
        data[1,0,1] = 'w7x2_113_116.dat'
        data[2,0,1] = 'w7x2_117_120.dat'
        data[3,0,1] = 'w7x2_121_124.dat'
        data[4,0,1] = 'w7x2_153_156.dat'      
        data[0,1,1] = 'w7x2_125_128.dat'
        data[1,1,1] = 'w7x2_129_132.dat'
        data[2,1,1] = 'w7x2_133_136.dat'
        data[3,1,1] = 'w7x2_137_140.dat'
        data[4,1,1] = 'w7x2_157_160.dat'  
        #
        
    elif 'tj20' in equil:
        cases  =['Low n', 'High n']
        casesl =['low_n', 'high_n']
        sps    =['C6', 'W15']
        splab  =['C$^{6+}$', 'W$^{15+}$']
        fmtsp  =['o', '^']
        colsp  =['black', 'blue']
        a      = rmin('tj20')[0]
        equ    = 'TJ-II'
        
        data = empty((size(cases),2,size(sps)), dtype='|S20')
        
        
        # [case, phi, z]
        data[0,0,0] = 'tj20_393_396.dat'
        data[1,0,0] = 'tj20_389_392.dat'
        data[0,1,0] = 'tj20_401_404.dat'
        data[1,1,0] = 'tj20_397_400.dat'
        #
        data[0,0,1] = 'tj20_431_434.dat'
        data[1,0,1] = 'tj20_405_408.dat'
        data[0,1,1] = 'tj20_439_442.dat'
        data[1,1,1] = 'tj20_435_438.dat'
        #
    
    icase = cases.index(case)
    isp   = sps.index(species)
    
    datafile0 = path + equil + '/data/' + data[icase, 0, isp]
    datafile1 = path + equil + '/data/' + data[icase, 1, isp]

    # We load: s, nz, pflux1, error
    values0   = loadtxt(datafile0, dtype='float', usecols=(2,14,17,18))
    values1   = loadtxt(datafile1, dtype='float', usecols=(2,14,17,18))

    if sfincs == 1:
        datasfincs0 = path + equil + '/data/' + datasfincs[icase, 0, isp]
        datasfincs1 = path + equil + '/data/' + datasfincs[icase, 1, isp]
        sfincs0    = loadtxt(datasfincs0, dtype='float', usecols=(0,1,2))
        sfincs1    = loadtxt(datasfincs1, dtype='float', usecols=(0,1,2))
    
    rho0      = sqrt(values0[:,0])
    rho1      = sqrt(values1[:,0])
    pfluxn0   = values0[:,2]/values0[:,1]
    pfluxn1   = values1[:,2]/values0[:,1]
    error0    = values0[:,3]/values0[:,1]
    error1    = values1[:,3]/values0[:,1]
    x0spl     = np.linspace(rho0[0], rho0[3], nspl)
    yspl      = UnivariateSpline(rho0, pfluxn0)
    y0spl     = yspl(x0spl)
    x1spl     = np.linspace(rho1[0], rho1[3], nspl)
    yspl      = UnivariateSpline(rho1, pfluxn1)
    y1spl     = yspl(x1spl)  
    #Plotting
    #
    if yrange == None or size(yrange)==2:
        fig = plt.figure(num=None, figsize = (8.0,8.0), dpi = 100)
        subplots_adjust(left=0.20, bottom=0.10, right=0.95, top=0.95,\
                        wspace=0.00, hspace=0.00)
        ax= fig.add_subplot(111)

        ax.plot(x0spl, y0spl, linestyle='--', color=colsp[isp], linewidth=2.5)
        ax.plot(x1spl, y1spl, linestyle='-', color=colsp[isp], linewidth=2.5)
                   

        if sfincs == 1:
            ax.errorbar(rho0, pfluxn0, yerr=error0, fmt=fmtsp[isp], color=colsp[isp],\
                        markersize=10, mfc = 'white', markeredgewidth=2.5, mec=colsp[isp],\
                        label="w/o $\Phi_1$ (EUTERPE)")
            ax.errorbar(rho1, pfluxn1, yerr=error1, fmt=fmtsp[isp], color=colsp[isp] ,\
                        markersize=10, mfc = colsp[isp], markeredgewidth=2.5, mec=colsp[isp],\
                        label="w/  $\Phi_1$ (EUTERPE)")
            ax.errorbar (sfincs0[:,0], sfincs0[:,1], yerr=sfincs0[0,2],fmt='*', color='r',\
                     markersize=14, mfc = 'white', markeredgewidth=2.5, mec='r', label="w/o $\Phi_1$ (SFINCS)")
            ax.errorbar(sfincs1[:,0], sfincs1[:,1], yerr=sfincs1[0,2],fmt='*', color='r',\
                     markersize=14, mfc = 'r', markeredgewidth=2.5, mec='r', label="w/  $\Phi_1$ (SFINCS)")
            
#            ax.plot(sfincs0[:,0], sfincs0[:,1], '*', color='r',\
#                     markersize=14, mfc = 'white', markeredgewidth=2.5, mec='r', label="w/o $\Phi_1$ (SFINCS)")
#            ax.plot(sfincs1[:,0], sfincs1[:,1], '*', color='r',\
#                     markersize=14, mfc = 'r', markeredgewidth=2.5, mec='r', label="w/  $\Phi_1$ (SFINCS)")
            
        else:
            ax.errorbar(rho0, pfluxn0, yerr=error0, fmt=fmtsp[isp], color=colsp[isp],\
                        markersize=10, mfc = 'white', markeredgewidth=2.5, mec=colsp[isp],\
                        label="w/o $\Phi_1$")
            ax.errorbar(rho1, pfluxn1, yerr=error1, fmt=fmtsp[isp], color=colsp[isp] ,\
                        markersize=10, mfc = colsp[isp], markeredgewidth=2.5, mec=colsp[isp],\
                        label="w/  $\Phi_1$")
            
            
        ax.set_xlabel("$r/a$", fontsize=22)
        ax.set_ylabel(labely, fontsize=22)
        ax.set_xlim([0,1])
        if size(yrange)==2:
            ax.set_ylim(yrange)
        ax.grid(color='grey', linestyle='--', linewidth=0.2)
        ax.yaxis.set_minor_locator(AutoMinorLocator(10))
        ax.xaxis.set_minor_locator(AutoMinorLocator(10))
        titlestr = equ + ' / ' + cases[icase] + ' / ' + splab[isp]
        ax.legend(loc=pos, prop={'size':20}, title=titlestr )

    elif yrange !=None and size(yrange)==4:
        fig,(ax,ax2) =plt.subplots(2,1,sharex=True, figsize = (8.5,8.0))
        subplots_adjust(left=0.15, right=0.95, wspace=4.00, hspace=0.15, top=0.95)
        ax2.plot(x0spl, y0spl, linestyle='--', color=colsp[isp], linewidth=2.5)
        ax2.errorbar(rho0, pfluxn0, yerr=error0, fmt=fmtsp[isp], color=colsp[isp],\
                    markersize=10, mfc = 'white', markeredgewidth=2.5, mec=colsp[isp], label="w/o $\Phi_1$")

        if spl==0:
            ax2.errorbar(rho1, pfluxn1, yerr=error1, fmt=fmtsp[isp]+'-', color=colsp[isp] ,\
                         markersize=10, mfc = colsp[isp], markeredgewidth=2.5, mec=colsp[isp], label="w/  $\Phi_1$")
        elif spl==1:
                
            ax2.plot(x1spl, y1spl, linestyle='-', color=colsp[isp], linewidth=2.5)
            ax2.errorbar(rho1, pfluxn1, yerr=error1, fmt=fmtsp[isp], color=colsp[isp] ,\
                     markersize=10, mfc = colsp[isp], markeredgewidth=2.5, mec=colsp[isp], label="w/  $\Phi_1$")
        
        ax2.set_ylim(yrange[0], yrange[1])



        ax.plot(x0spl, y0spl, linestyle='--', color=colsp[isp], linewidth=2.5)
        ax.errorbar(rho0, pfluxn0, yerr=error0, fmt=fmtsp[isp], color=colsp[isp],\
                    markersize=10, mfc = 'white', markeredgewidth=2.5, mec=colsp[isp], label="w/o $\Phi_1$")
        
        if spl==1:
            ax.plot(x1spl, y1spl, linestyle='-', color=colsp[isp], linewidth=2.5)      
            ax.errorbar(rho1, pfluxn1, yerr=error1, fmt=fmtsp[isp], color=colsp[isp] ,\
                        markersize=10, mfc = colsp[isp], markeredgewidth=2.5, mec=colsp[isp], label="w/  $\Phi_1$")
        elif spl==0:
            ax.errorbar(rho1, pfluxn1, yerr=error1, fmt=fmtsp[isp]+'-', color=colsp[isp] ,\
                     markersize=10, mfc = colsp[isp], markeredgewidth=2.5, mec=colsp[isp], label="w/  $\Phi_1$")

        ax.set_xlim([0,1])
        ax.grid(color='grey', linestyle='--', linewidth=0.2)
        ax2.grid(color='grey', linestyle='--', linewidth=0.2)
         
        ax.set_ylim(yrange[2], yrange[3])

        ax2.set_xlabel("$r/a$", fontsize=22)
        ax2.set_ylabel(labely, fontsize=22, position=(0.0,1.1))

        ax.yaxis.set_minor_locator(AutoMinorLocator(10))
        ax.xaxis.set_minor_locator(AutoMinorLocator(10))
        ax2.yaxis.set_minor_locator(AutoMinorLocator(10))
        titlestr = equ + ' / ' + cases[icase] + ' / ' + splab[isp]
        ax.legend(loc=pos, prop={'size':20}, title=titlestr )

        
        ax.spines['bottom'].set_visible(False)
        ax2.spines['top'].set_visible(False)
        
        ax.xaxis.tick_top()
        ax.tick_params(labeltop='off') # don't put tick labels at the top
        ax2.xaxis.tick_bottom()
        
        d = .015

        kwargs = dict(transform=ax.transAxes, color='k', clip_on=False)
        ax.plot((-d,+d),(-d,+d), **kwargs)
        ax.plot((1-d,1+d),(-d,+d), **kwargs)

        kwargs.update(transform=ax2.transAxes)
        ax2.plot((-d,+d),(1-d,1+d), **kwargs)
        ax2.plot((1-d,1+d),(1-d,1+d), **kwargs)
        
    plt.show(block=False)
    if equil=='tj20':
        epsname= plotdir + equil + '_' + casesl[icase] + '_' + sps[isp] + runs + '.eps'
    else:
        epsname= plotdir + equil + '_' + cases[icase] + '_' + sps[isp] + runs + '.eps'
        
        if sfincs == 1:
            epsname= plotdir + equil + '_' + cases[icase] + '_' + sps[isp] + runs + '_w_SFINCS.eps'
            
    print epsname
    fig.savefig(epsname, format='eps', dpi=1000)

def thf():

    datadir = '/home/jose/afs/Trabajo/Results/2014_z_flux_with_phi1/non_mirror_rest/lhd2/data/'
    data = empty((2,6), dtype='|S120')
    labely = '$\left<\Gamma_{Z}\cdot\\nabla r\\right>/n_{0Z}\ [\\mathrm{m}\ \\mathrm{s}^{-1}]$'
    
    # [0,1][0,1,2,3] = [w/o phi1, w/ phi1][n', T', Er, Phi1(T'/T)]
    
    data[0,0] = datadir + 'lhd2_B.III_C6_wo_Phi1_np.dat'
    data[0,1] = datadir + 'lhd2_B.III_C6_wo_Phi1_tp.dat'
    data[0,2] = datadir + 'lhd2_B.III_C6_wo_Phi1_er.dat'

    data[1,0] = datadir + 'lhd2_B.III_C6_w_Phi1_np.dat'
    data[1,1] = datadir + 'lhd2_B.III_C6_w_Phi1_tp.dat'
    data[1,2] = datadir + 'lhd2_B.III_C6_w_Phi1_er.dat'
    data[1,3] = datadir + 'lhd2_B.III_C6_w_Phi1_p1.dat'

    # We load: s, acting Th. force, nz, pflux1, error
    val_np_0   = loadtxt(data[0,0], dtype='float', usecols=(2,13,14,17,18))
    val_tp_0   = loadtxt(data[0,1], dtype='float', usecols=(2,5,14,17,18))
    val_er_0   = loadtxt(data[0,2], dtype='float', usecols=(2,1,14,17,18))

    val_np_1   = loadtxt(data[1,0], dtype='float', usecols=(2,13,14,17,18))
    val_tp_1   = loadtxt(data[1,1], dtype='float', usecols=(2,7,14,17,18))
    val_er_1   = loadtxt(data[1,2], dtype='float', usecols=(2,1,14,17,18))
    val_p1_1   = loadtxt(data[1,3], dtype='float', usecols=(2,14,17,18))        
     
    rho      = sqrt(val_np_0[:,0])
    x0spl     = np.linspace(rho[0], rho[3], 100)
 
    pflux_np_0  = val_np_0[:,2]/val_np_0[:,2]; yspl = UnivariateSpline(rho, pflux_np_0); yspl_np_0=yspl(x0spl)
    pflux_tp_0  = val_tp_0[:,2]/val_tp_0[:,2]; yspl = UnivariateSpline(rho, pflux_tp_0); yspl_tp_0=yspl(x0spl)
    pflux_er_0  = val_er_0[:,2]/val_er_0[:,2]; yspl = UnivariateSpline(rho, pflux_er_0); yspl_er_0=yspl(x0spl)
    eflux_np_0  = val_np_0[:,3]/val_np_0[:,2]
    eflux_tp_0  = val_tp_0[:,3]/val_tp_0[:,2]
    eflux_er_0  = val_er_0[:,3]/val_er_0[:,2]
        
    pflux_np_1  = val_np_1[:,2]/val_np_1[:,2]; yspl = UnivariateSpline(rho, pflux_np_1); yspl_np_1=yspl(x0spl)
    pflux_tp_1  = val_tp_1[:,2]/val_tp_1[:,2]; yspl = UnivariateSpline(rho, pflux_tp_1); yspl_tp_1=yspl(x0spl)
    pflux_er_1  = val_er_1[:,2]/val_er_1[:,2]; yspl = UnivariateSpline(rho, pflux_er_1); yspl_er_1=yspl(x0spl)
    pflux_p1_1  = val_p1_1[:,2]/val_p1_1[:,1]; yspl = UnivariateSpline(rho, pflux_p1_1); yspl_p1_1=yspl(x0spl)
    eflux_np_1  = val_np_1[:,3]/val_np_1[:,2]
    eflux_tp_1  = val_tp_1[:,3]/val_tp_1[:,2]
    eflux_er_1  = val_er_1[:,3]/val_er_1[:,2]
    eflux_p1_1  = val_p1_1[:,3]/val_p1_1[:,1]

    # For the thermodynamic forces analysis
    
    fig = plt.figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.20, bottom=0.10, right=0.95, top=0.95,\
                    wspace=0.00, hspace=0.00)
    ax= fig.add_subplot(111)


    ax.plot(x0spl, yspl_np_0, linestyle='-', color='r', linewidth=2.5)
    ax.plot(x0spl, yspl_tp_0, linestyle='-', color='b', linewidth=2.5)
    ax.plot(x0spl, yspl_er_0, linestyle='-', color='g', linewidth=2.5)                   
    ax.errorbar(rho, pflux_np_0, yerr=eflux_np_0, fmt='o', color='r',\
                        markersize=10, mfc = 'white', markeredgewidth=2.5, mec='r',\
                        label="$n'/n$")
    ax.errorbar(rho, pflux_tp_0, yerr=eflux_tp_0, fmt='s', color='b',\
                        markersize=10, mfc = 'white', markeredgewidth=2.5, mec='b',\
                        label="$T'/T$")
    ax.errorbar(rho, pflux_er_0, yerr=eflux_er_0, fmt='^', color='g',\
                markersize=10, mfc = 'white', markeredgewidth=2.5, mec='g',\
                label="$q\Phi\'_0/T$")
           
    ax.set_xlabel("$r/a$", fontsize=22)
    ax.set_ylabel(labely, fontsize=22)
    ax.set_xlim([0,1])
    ax.set_ylim([-1.5,0.5])
    ax.grid(color='grey', linestyle='--', linewidth=0.2)
    ax.yaxis.set_minor_locator(AutoMinorLocator(10))
    ax.xaxis.set_minor_locator(AutoMinorLocator(10))
    ax.legend(loc=4, prop={'size':20}, title='')

    #####################################################################

    fig2 = plt.figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.20, bottom=0.10, right=0.95, top=0.95,\
                    wspace=0.00, hspace=0.00)
    ax2= fig2.add_subplot(111)


    ax2.plot(x0spl, yspl_np_1, linestyle='-', color='r', linewidth=2.5)
    ax2.plot(x0spl, yspl_tp_1, linestyle='-', color='b', linewidth=2.5)
    ax2.plot(x0spl, yspl_er_1, linestyle='-', color='g', linewidth=2.5)
    ax2.plot(x0spl, yspl_p1_1, linestyle='-', color='orange', linewidth=2.5)    
    ax2.errorbar(rho, pflux_np_1, yerr=eflux_np_0, fmt='o', color='r',\
                        markersize=10, mfc = 'r', markeredgewidth=2.5, mec='r',\
                        label="$n'/n$")
    ax2.errorbar(rho, pflux_tp_1, yerr=eflux_tp_0, fmt='s', color='b',\
                        markersize=10, mfc = 'b', markeredgewidth=2.5, mec='b',\
                        label="$T'/T$")
    ax2.errorbar(rho, pflux_er_1, yerr=eflux_er_0, fmt='^', color='g',\
                markersize=10, mfc = 'g', markeredgewidth=2.5, mec='g',\
                label="$q\Phi\'_0/T$")
    ax2.errorbar(rho, pflux_p1_1, yerr=eflux_er_0, fmt='*', color='orange',\
                markersize=10, mfc = 'orange', markeredgewidth=2.5, mec='orange',\
                label="$(T'/T)q\Phi_1/T$")
    
    ax2.set_xlabel("$r/a$", fontsize=22)
    ax2.set_ylabel(labely, fontsize=22)
    ax2.set_xlim([0,1])

    ax2.set_ylim([-1.5,0.5])
    ax2.grid(color='grey', linestyle='--', linewidth=0.2)
    ax2.yaxis.set_minor_locator(AutoMinorLocator(10))
    ax2.xaxis.set_minor_locator(AutoMinorLocator(10))
    ax2.legend(loc=3, prop={'size':20}, title='')

    ############################################

    fig3 = plt.figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.20, bottom=0.10, right=0.95, top=0.95,\
                    wspace=0.00, hspace=0.00)
    ax3= fig3.add_subplot(111)


    ax3.plot(x0spl, yspl_np_1+yspl_tp_1+yspl_er_1+yspl_p1_1, linestyle='-', color='r', linewidth=2.5)
    ax3.plot(rho, pflux_np_1+pflux_tp_1+pflux_er_1+pflux_p1_1, color='r',\
             markersize=10, mfc = 'r', markeredgewidth=2.5, mec='r',\
             label="$w/ \Phi_1$")
    ax3.plot(x0spl, yspl_np_0+yspl_tp_0+yspl_er_0, linestyle='-', color='r', linewidth=2.5)
    ax3.plot(rho, pflux_np_0+pflux_tp_0+pflux_er_0, color='r',\
                        markersize=10, mfc = 'w', markeredgewidth=2.5, mec='r',\
                        label="$w/o \Phi_1$")
    ax3.set_xlabel("$r/a$", fontsize=22)
    ax3.set_ylabel(labely, fontsize=22)
    ax3.set_xlim([0,1])
    ax3.set_ylim([-1.5,0.5])
    ax3.grid(color='grey', linestyle='--', linewidth=0.2)
    ax3.yaxis.set_minor_locator(AutoMinorLocator(10))
    ax3.xaxis.set_minor_locator(AutoMinorLocator(10))
    ax3.legend(loc=3, prop={'size':20}, title='')
    
    show()


def func(x, D, V):
    return -D * x + V

def diag2d(case, species=-1, t0=0, tf=0, time=-1, si=1, title='None',\
           nmark=0, dens=1, flux=0, cont2='None', output='none', probe=[0.0,0.0], plot=1):
    
    # This function, reads the file ./diag2d_*.dat
    
    # Finding out what file is read and load the stored binary data
    # cont2: scalar field in theta phi that taken as input can be superimposed
    #        to the figures of diag2d
    
    diagfile = runsdir() + case + diag2d_case(case)
#    diagfile = runsdir() + case + '/diag2d_e.dat'
    diag_data  = open(diagfile, 'rb')

    # Defining time intervals of interest
    hist_time  = read_history(case, 0, species=species)
    # To make the time avrg along all the time history
    # when something different is not specified
    #if tf == 0: tf = hist_time[size(hist_time)-1]
    #if t0 == 0: t0 = hist_time[0]

    # If the 2D maps want to be represente at a specific
    # time between initial and last history time value (time=0 or 1)
    # the nearest location of that time is found for later storage
    if time >= 0 : timeloc = int(time/(hist_time[1]-hist_time[0]))
    if t0 != 0 and tf == 0:
        tf = hist_time[size(hist_time) - 2]
    if t0 != 0 and tf > hist_time[size(hist_time) - 2]:
        tf = hist_time[size(hist_time) - 2]
    
    iavr = 0
    
    # Reading the header
    rb_value(diag_data,'1i')
    VERNUM          = rb_value(diag_data,'1d'); rb_value(diag_data)
    complex_version = rb_value(diag_data,'1i'); rb_value(diag_data)
    elmag           = rb_value(diag_data,'1i'); rb_value(diag_data)
    nchi            = rb_value(diag_data,'1i')
    nphi            = rb_value(diag_data,'1i')
    nfp             = rb_value(diag_data,'1i'); rb_value(diag_data)
    #
    #
    timearr   = read_history(case,0, species)
    probe_val = zeros(size(time))
    delta_phi = 2*pi/(nfp*(nphi))
    delta_chi = 2*pi/(nchi)
    probe_phi = int(probe[0]/delta_phi)
    probe_chi = int(probe[1]/delta_chi)
    
    # Contructing phi and chi arrays
    phi = zeros(nphi)
    chi = zeros(nchi)
    nm_sum  = zeros([nphi,nchi])
    n0_sum  = zeros([nphi,nchi])
    n1_sum  = zeros([nphi,nchi])
    pf0_s_sum = zeros([nphi,nchi])
    pf1_s_sum = zeros([nphi,nchi])
    pf0_chi_sum = zeros([nphi,nchi])
    pf1_chi_sum = zeros([nphi,nchi])
    pf0_phi_sum = zeros([nphi,nchi])
    pf1_phi_sum = zeros([nphi,nchi])
    a_zi_sum    = zeros([nphi,nchi])
    delta_phi = 2*pi/(nfp*(nphi))
    delta_chi = 2*pi/(nchi)
    
    for j in range(0,nphi):
        phi[j]= 2*pi*j/(nfp*(nphi))
    for j in range(0,nchi):
        chi[j]=2*pi*j/(nchi)
        
    # Reading initial block of data
    simtime = rb_value(diag_data,'1d'); rb_value(diag_data)

    nm      = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    n0      = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    n1      = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    pf0_s   = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    pf1_s   = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    pf0_chi = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    pf1_chi = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    pf0_phi = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    pf1_phi = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
    a_zi    = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data,'1i')
    
    nm      = reshape(nm,(nphi,nchi))
    n0      = reshape(n0,(nphi,nchi))
    n1      = reshape(n1,(nphi,nchi))


    
    # Loop to read the blocks of data in each simtime    
    for i in range (1, size(hist_time)):

        rb_value(diag_data,'1i')
        simtime = rb_value(diag_data,'1d'); rb_value(diag_data)
        
        print i, simtime

        nm      = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)        
        n0      = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
        n1      = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
        pf0_s   = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
        pf1_s   = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
        pf0_chi = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
        pf1_chi = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
        pf0_phi = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
        pf1_phi = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data)
        a_zi    = rb_value(diag_data,str(nchi*nphi) + 'd'); rb_value(diag_data,'1i')

        # Reshaping
        nm      = reshape(nm,(nphi,nchi))      
        n0      = reshape(n0,(nphi,nchi))
        n1      = reshape(n1,(nphi,nchi))
        pf0_s   = reshape(pf0_s,(nphi,nchi))
        pf1_s   = reshape(pf1_s,(nphi,nchi))
        pf0_chi = reshape(pf0_chi,(nphi,nchi))
        pf1_chi = reshape(pf1_chi,(nphi,nchi))
        pf0_phi = reshape(pf0_phi,(nphi,nchi))
        pf1_phi = reshape(pf1_phi,(nphi,nchi))
        a_zi    = reshape(a_zi,(nphi,nchi))
#        print probe_phi, probe_chi
#        probe_val[j] = a_zi[probe_phi,probe_chi]
        
        if time < 0:
            if t0 != 0:
                # Time average of the diagnosed maps is assumed
                if simtime > t0 and simtime < tf:
                    nm_sum = nm_sum + nm
                    n0_sum = n0_sum + n0
                    n1_sum = n1_sum + n1
                    pf0_s_sum = pf0_s_sum + pf0_s
                    pf1_s_sum = pf1_s_sum + pf1_s
                    pf0_chi_sum = pf0_chi_sum + pf0_chi
                    pf1_chi_sum = pf1_chi_sum + pf1_chi
                    pf0_phi_sum = pf0_phi_sum + pf0_phi
                    pf1_phi_sum = pf1_phi_sum + pf1_phi
                    a_zi_sum    = a_zi_sum    + a_zi
                    #
                    iavr   = iavr + 1
                    #
                    nm_avr = nm_sum / float(iavr)
                    n0_avr = n0_sum / float(iavr)
                    n1_avr = n1_sum / float(iavr)
                    pf0_s_avr = pf0_s_sum / float(iavr)
                    pf1_s_avr = pf1_s_sum / float(iavr)
                    pf0_chi_avr = pf0_chi_sum / float(iavr)
                    pf1_chi_avr = pf1_chi_sum / float(iavr)
                    pf0_phi_avr = pf0_phi_sum / float(iavr)
                    pf1_phi_avr = pf1_phi_sum / float(iavr)
                    a_zi_avr    = a_zi_sum    / float(iavr)
                if simtime >= tf :
                    print 'Time average performed in: '
                    print 'Interval (t0, tf) = (',t0,', ',tf,')'
                    print 'Sim. times read   = ', iavr
                    nm     = nm_avr
                    n0     = n0_avr
                    n1     = n1_avr
                    pf0_s  = pf0_s_avr
                    pf1_s  = pf1_s_avr
                    pf0_chi  = pf0_chi_avr
                    pf1_chi  = pf1_chi_avr
                    pf0_phi  = pf0_phi_avr
                    pf1_phi  = pf1_phi_avr
                    a_zi     = a_zi_avr 
                    break

        elif time >= 0:
            # We exit with the last maps read
            if simtime > hist_time[timeloc]:
                break

    if si == 1:
        nstar   = norm(case)[6]
        pfdstar = norm(case)[12]
        rstar   = norm(case)[0]
        vstar   = norm(case)[3]
    elif si == 0:
        nstar = 1.
        pfdstar = 1.
        
    if output != 'none':
        if "/" in case:
            hpc      = case.split("/")[0]
            run      = case.split("/")[1]
        else:
            hpc      = ""
            run      = case
    if output == "azi":
        out_data = datadir() + 'azi_' + hpc + '_' + run + '.dat'
        quantity = make_per_2d(matin = a_zi_avr * vstar)
    elif output == 'n1':
        out_data = datadir() + 'n1_' + hpc + '_' + run + '.dat'
        quantity = make_per_2d(matin = n1_avr   * nstar)
    elif output == 'n0':
        out_data = datadir() + 'n0_' + hpc + '_' + run + '.dat'
        quantity = make_per_2d(matin = n0_avr   * nstar)
        
    if output !="none":
        f        = open(out_data,'w')
        f.write('# Postprocessed output from file: ' + diagfile + '\n')
        f.write('# Time average interval         : ' + str(t0) + '\t' + str(tf)  +'\n')
        f.write('# load_s0, nchi, nphi, nfp' + '\n#\n')
        f.write(str(load_s0(case))+'\n')
        f.write(str(nchi+1)+'\n')
        f.write(str(nphi+1)+'\n')
        f.write(str(nfp)+'\n')       
        
        for i_chi in range(0,nchi+1):
            for i_phi in range(0,nphi+1):
                f.write(str(quantity[i_phi, i_chi])+'\t')
            f.write('\n')
        f.close()
    #
    print 'Mean Nm  value in (theta,phi) = ', mean(nm)
    print 'Mean n0  value in (theta,phi) = ', mean(n0)*nstar
    print 'Mean n1  value in (theta,phi) = ', mean(n1)*nstar
    print 'Mean(n1)/Mean(n0)             = ', mean(n1)/mean(n0)
    print 'Mean(n1/n0)                   = ', mean(n1/n0)
    print 'Max(|n1/n0|)                  = ', (abs(n1/n0).max())
    print 'Min(|n1/n0|)                  = ', (abs(n1/n0).min())
    print 'Max(|a_zi|)                   = ', (abs(a_zi*vstar).max())
    print 'Mean(|a_zi|)                  = ', mean(abs(a_zi*vstar))
    
    for i in arange (0, nphi):
        for j in arange (0, nchi):
            if abs(a_zi[i,j])==abs(a_zi).max():
                
                print 'iphi, ichi = ', i, j
            
    #
    if cont2=='drifts':
        cont2 = flsurf(case, species=species, get='drifts').transpose()
    elif cont2=='mirror':
        cont2 = flsurf(case, species=species, get='mirror').transpose()

    if plot == 1:
##        plmap(xdata=phi, ydata=chi,zdata=(n1.transpose()/n0.transpose()),\
##              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$n_1/n_0$',num=1, contour=0, cont2=cont2)
        
##        plmap(xdata=phi, ydata=chi,zdata=n1.transpose()*nstar,\
##              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$n_1$ [m$^{-3}$]',num=1, contour=0, cont2=cont2)
        
        plmap(xdata=phi, ydata=chi,zdata=a_zi.transpose()*vstar,\
              xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$A$ [m s $^{-1}$]',\
              num=1, contour=0, cont2=cont2)
        

#    fig01(data_x=timearr, data_y=probe_val, xlabel='x', ylabel='y', bar=[0.0,0.0], \
#          ls='r-', mean = 0.0, error=0.0, xrange=[0.0,0.0], yrange=[0.0,0.0], num=0,\
#          label=[])

        if nmark == 1:
            # PLOTTING NM
            plmap(xdata=phi, ydata=chi,zdata=nm.transpose(),\
                  xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$N_m$',num=1, contour=0) 
#        if dens == 1: 
#            # PLOTTING N0
##            plmap(xdata=phi, ydata=chi,zdata=n0.transpose()*nstar,\
##                  xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]', zlabel='$n_0$ [m$^{-3}$]',num=1, contour=0)
        
        if flux == 1:
            # PLOTTING PARTICLE FLUX0 across and on the surface
            if neo_eang(case)== 1:
                zlabel = '$\\int f_0 (\\mathbf{v}_{d}+ \\mathbf{v}_{E1})\
                \\cdot\\nabla r  \\mathrm{d}^{3}v$ [m$^{-2}$ s$^{-1}$]'
            elif neo_eang(case) == 0:
                zlabel = '$\\int f_0 \\mathbf{v}_{d})\
                \\cdot\\nabla r  \\mathrm{d}^{3}v$ [m$^{-2}$ s$^{-1}$]'    
            plmap(xdata=phi, ydata=chi,zdata=pf0_s.transpose()*pfdstar,\
                  xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]',\
                  zlabel=zlabel, num=1, contour=0,\
                  vfield=1, vxdata=(pf0_phi).transpose()*pfdstar,\
                  vydata=(pf0_chi).transpose()*pfdstar)
            
            # PLOTTING PARTICLE FLUX0 across and on the surface
            if neo_eang(case)== 1:
                zlabel = '$\\int f_1 (\\mathbf{v}_{d}+ \\mathbf{v}_{E1})\
                \\cdot\\nabla r  \\mathrm{d}^{3}v$ [m$^{-2}$ s$^{-1}$]'
            elif neo_eang(case) == 0:
                zlabel = '$\\int f_1 \\mathbf{v}_{d}\
                \\cdot\\nabla r  \\mathrm{d}^{3}v$ [m$^{-2}$ s$^{-1}$]'
                
            plmap(xdata=phi, ydata=chi,zdata=pf1_s.transpose()*pfdstar,\
                  xlabel='$\phi$ [rad]', ylabel='$\\theta$ [rad]',\
                  zlabel=zlabel, num=1, contour=0,\
                  vfield=1, vxdata=(pf1_phi).transpose()*pfdstar,\
                  vydata=(pf1_chi).transpose()*pfdstar)
    

    # PLOTTING PARTICLE FLUX on the SURFACE (PFLUX0 + PFLUX1)
    
        pflux(case, t0, tf, species=species, si=0)
        
        show(block=False)

def f_prof_0(svalue, q0=1.0, kappa=1.0, speak=0.5, width=0.2, der=0, s_norm=0.5):

    # svalue : value of s=(r/a)^2
    # q0     : value of T0 or n0 at s=0
    # kappa  : dLnq/ds

    c0      = 1. / (cosh(speak/width))**2.0

    if der == 0:
        f_value = q0 (kappa * width / (1. -  c0))*( tanh((svalue - speak)/ width) -\
                                                    c0 * (svalue - speak) / width )
    elif der ==1:
        f_value =    (kappa / (1. -  c0))*( 1/(cosh((svalue - speak)/ width))**2. - c0 )

    return format2(f_value)

def getquant2d(file='none', out='none', crange='none', plot=1):
    
    text_file = open(file, "r")
    lines     = text_file.readlines()
    svalue    = float(lines[4])
    nchi      = int(lines[5])
    nphi      = int(lines[6])
    nfp       = int(lines[7])
    
    quant2d = loadtxt(file, dtype='float', skiprows=8)

    chi   = arange(0,nchi)*2*pi/(nchi-1)
    phi   = arange(0,nphi)*2*pi/(nphi-1)/nfp

    X, Y = meshgrid(phi, chi)
    
    if plot == 1:
            plmap(phi, chi, quant2d, ctics=1, contour=0, xlabel='$\\phi$ [rad]', crange=crange,\
                  ylabel='$\\theta$ [rad]', zlabel='$\\Phi_1$ [V]')
            
    if(out=='chi'): return chi
    if(out=='phi'): return phi
    if(out=='nfp'): return nfp
    if(out=='quant'): return quant2d
    
def getphi2d(file='none', out='phi2d', write='none', phistar=1.0, inter=0,\
             plot=0, crange='none'):

    text_file = open(file, "r")
    lines     = text_file.readlines()
    svalue    = float(lines[4])
    nchi      = int(lines[5])
    nphi      = int(lines[6])
    nfp       = int(lines[7])
    
    phi2d = loadtxt(file, dtype='float', skiprows=8)

    chi   = arange(0,nchi)*2*pi/(nchi-1)
    phi   = arange(0,nphi)*2*pi/(nphi-1)/nfp

    X, Y = meshgrid(phi, chi)
    
    if write == 'JL':
        out_file  = './phi2d_3cols.dat'
        f           = open(out_file,'w')
        
        f.write('# Postprocessed file: ' + file         + '\n')
        f.write('# phistar           = ' + str(phistar) + '\n')
        f.write('# svalue            = ' + str(svalue)    + '\n')
        f.write('# ntheta            = ' + str(nchi)    + '\n')
        f.write('# nzeta             = ' + str(nphi)    + '\n')
        f.write('# nfp               = ' + str(nfp)     + '\n')
        f.write('# zeta\t theta\t Phi1[V]\n')
        for iphi in arange(0, nphi):
            for ichi in arange(0, nchi):
                f.write(str(format5(phi[iphi]))+'\t'+\
                        str(format5(chi[ichi]))+'\t'+\
                        str(format5(phi2d[ichi, iphi]*phistar))+'\n')
          
    if inter == 1:
        #xx, yy = meshgrid(phi, chi)
        #f      = interpolate.interp2d(xx, yy, phi2d.transpose(), kind='cubic')
        
        nchint = 257
        nphint = 257
        chivi  = arange(0,nchint)*2*pi/(nchint - 1)
        phivi  = arange(0,nphint)*2*pi/(nphint - 1)/10


        #xxx, yyy = meshgrid(phivi, chivi)
        #phi2dn = f(phivi, chivi)
        #plmap(phivi, chivi, phi2dn,contour=0)
        phi2dn=RectBivariateSpline(phi,chi,phi2d.transpose())(phivi,chivi,grid=True)
        plmap(phivi, chivi, phi2dn.transpose(),contour=0)

        f        = open('phi2dint.dat','w')
        f.write('# Postprocessed and smoothed output from file: ' + file + '\n')
        f.write('#' + '\n')
        f.write('# load_s0, nchi, nphi, nfp' + '\n#\n')
        f.write(str(svalue)+'\n')
        f.write(str(nchint)+'\n')
        f.write(str(nphint)+'\n')
        f.write(str(nfp)+'\n')
        for i_chi in range(0,nchint):
            for i_phi in range(0,nphint):
                f.write(str(phi2dn[i_phi,i_chi])+'\t')
            f.write('\n')
        f.close()


    if plot == 1:
            plmap(phi, chi, phi2d, ctics=1, contour=1, xlabel='$\\phi$ [rad]', crange=crange,\
                  ylabel='$\\theta$ [rad]', zlabel='$\\Phi_1$ [V]')
    if(out=='chi'): return chi
    if(out=='phi'): return phi
    if(out=='nfp'): return nfp
    if(out=='phi2d'): return phi2d


def phi2d_check(case='none'):

    nchi = 64
    nphi = 64

    chiv = arange(0, nchi)*2*pi/nchi
    phiv = arange(0, nphi)*2*pi/nphi/10

    phi1      = empty((nphi,nchi), dtype='float')
    dphi1dchi = empty((nphi,nchi), dtype='float')
    dphi1dphi = empty((nphi,nchi), dtype='float')

    dphi1dphi[:,:] = 0.0
    dphi1dchi[:,:] = 0.0
    
    for ichi in arange(0, nchi):
        for iphi in arange(0, nphi):
            a,b,c = phi2d_interpol(case=case, chit=chiv[ichi], phit=phiv[iphi])
            phi1[iphi, ichi]     =a
            dphi1dphi[iphi, ichi]=b
            dphi1dchi[iphi, ichi]=c
            
            print ichi, iphi, phi1[iphi, ichi], dphi1dphi[iphi, ichi], dphi1dchi[iphi, ichi]
            

    plmap(phiv, chiv,phi1.transpose(), contour=1, zlabel='Phi1')
    plmap(phiv, chiv,dphi1dphi.transpose(), contour=1, zlabel='dPhi1dzeta')
    plmap(phiv, chiv,dphi1dchi.transpose(), contour=1, zlabel='dPhi1dtheta')

    
def phi2d_interpol(case='none', chit=1.5, phit=0.3):

    phi2dfile = runsdir()+ case + '/phi2d.dat'
    
    pot = empty((3,3), dtype='float')
    dpot_dchit = empty((3,3), dtype='float')
    dpot_dphit = empty((3,3), dtype='float')
    
    phi2d = getphi2d(file=phi2dfile)
    chiv  = getphi2d(file=phi2dfile, out='chi')
    phiv  = getphi2d(file=phi2dfile, out='phi')
    nfp   = getphi2d(file=phi2dfile, out='nfp')
    
    nchi  = size(chiv)
    nphi  = size(phiv)

    chit_step = 2.* pi / float(nchi-1)
    phit_step = 2.* pi / float(nfp*(nphi - 1))

    loc_chit1 = int(chit/chit_step)
    loc_phit1 = int(phit/phit_step)
    loc_chit2 = int(chit/chit_step) + 1
    loc_phit2 = int(phit/phit_step) + 1
    loc_chit3 = int(chit/chit_step) + 2
    loc_phit3 = int(phit/phit_step) + 2

    #   Note that Phi has periodic boundary values.
    #   Phi2d(nphi, :   ) = Phi2d( 1 , :)
    #   Phi2d(:   , nchi) = Phi2d( : , 1)
    #
    #   These are the phit and chit coordinates of
    #   of the grid cell where our marker is
    #
    phit1    = float(loc_phit1)        * phit_step
    phit2    = float(loc_phit1 + 1)    * phit_step
    chit1    = float(loc_chit1)        * chit_step
    chit2    = float(loc_chit1 + 1)    * chit_step
    #
    #   Delta(chit) and Delta(phit)
    #
    dphit1   = phit  - phit1
    dphit2   = phit2 - phit
    dchit1   = chit  - chit1
    dchit2   = chit2 - chit
    #
    #   Phi values necessary for bilinear interpolation
    #   at (phit,chit) of the electrostatic potential.
    #
    pot[0,0] = phi2d[loc_phit1, loc_chit1]
    pot[0,1] = phi2d[loc_phit1, loc_chit2]
    pot[1,0] = phi2d[loc_phit2, loc_chit1]
    pot[1,1] = phi2d[loc_phit2, loc_chit2]
    #
    #   Phi values necessary for bilinear interpolation
    #   of dPhidchit and dPhidphit at (phit,chit)
    #
    #   Achtung!: loc_phit3 can be > than nphi and loc_chit3
    #   loc_chit3 can be > than nchi.
    #
    if loc_chit3 == nchi:
        pot[0,2] = phi2d[loc_phit1, 1]
        pot[1,2] = phi2d[loc_phit2, 1]
    else:
        pot[0,2] = phi2d[loc_phit1, loc_chit3]
        pot[1,2] = phi2d[loc_phit2, loc_chit3]
    if loc_phit3 == nphi:
        pot[2,0] = phi2d[2, loc_chit1]
        pot[2,1] = phi2d[2, loc_chit2]
    else:
        pot[2,0] = phi2d[loc_phit3, loc_chit1]
        pot[2,1] = phi2d[loc_phit3, loc_chit2]
    #
    #   Computing the dPhi_dtheta in the cell nodes
    #
    dpot_dchit[0,0] = pot[0,1] - pot[0,0]
    dpot_dchit[0,1] = pot[0,2] - pot[0,1]
    dpot_dchit[1,0] = pot[1,1] - pot[1,0]
    dpot_dchit[1,1] = pot[1,2] - pot[1,1]
    dpot_dchit      = dpot_dchit / chit_step
    #
    #   Computing the dPhi_dphi in the cell nodes
    #
    dpot_dphit[0,0] = pot[1,0] - pot[0,0]
    dpot_dphit[0,1] = pot[1,1] - pot[0,1]
    dpot_dphit[1,0] = pot[2,0] - pot[1,0]
    dpot_dphit[1,1] = pot[2,1] - pot[1,1]
    dpot_dphit      = dpot_dphit / phit_step
    #
    #   Interpolated value of the potential at marker position.
    #
    pot_val   = ( pot[0,0] * dphit2 * dchit2 + \
                  pot[1,0] * dphit1 * dchit2 + \
                  pot[0,1] * dphit2 * dchit1 + \
                  pot[1,1] * dphit1 * dchit1 ) /\
                  chit_step / phit_step
    #
    #   Interpolated value of ~E_{chit} at marker position.
    #   Note that grad(chit) is left to get the proper field
    #
    dpot_dchit_val = - ( dpot_dchit[0,0]* dphit2 * dchit2 + \
                         dpot_dchit[1,0]* dphit1 * dchit2 + \
                         dpot_dchit[0,1]* dphit2 * dchit1 + \
                         dpot_dchit[1,1]* dphit1 * dchit1 )/chit_step / phit_step
    #
    #   Interpolated value of ~E_{phit} at marker position.
    #   Note that grad(chit) is left to get the proper field
    #
    dpot_dphit_val = - ( dpot_dphit[0,0] * dphit2 * dchit2 + \
                         dpot_dphit[1,0] * dphit1 * dchit2 + \
                         dpot_dphit[0,1] * dphit2 * dchit1 + \
                         dpot_dphit[1,1] * dphit1 * dchit1 ) / chit_step / phit_step

    return pot_val, dpot_dphit_val, dpot_dchit_val
    

    

def bing():

    kev2ev = 1000.
    
    datapath  = '/home/jose/Results/2016_Bing_phi1/case_no_bias/'
    
    phi1BD0 = datapath + 'phi1_te_corrected.dat'
    phi1BD1 = datapath + 'phi1_te_Erx1.4_corrected.dat'


    data0   = loadtxt(phi1BD0, dtype='float', usecols=(5,13,14))
    data1   = loadtxt(phi1BD1, dtype='float', usecols=(5,13,14))
    
    te0     = data0[:,0]*kev2ev
    phi1D0  = data0[:,1]
    phi1B0  = data0[:,2]
    dphi1BD0= phi1B0 - phi1D0

    te1     = data1[:,0]*kev2ev
    phi1D1  = data1[:,1]
    phi1B1  = data1[:,2]
    dphi1BD1= phi1B1 - phi1D1    

    probeB  = [0.26, 5.14]
    probeD  = [0.6, 1.87]
    
    # Data processing for phi2d contour plots
    # i,j = Er, Te
    #
    phi2dfile = empty((2,6), dtype='|S80')
    phi2d     = empty((2,6,65,257))
    phistar   = empty((2,6), dtype='float')

    phistar[0,:]   = [64.559616, 129.1795, 193.7012, 304.2606, 368.8713, 433.4212]
    phistar[1,:]   = [64.559616, 129.1795, 193.7012, 304.2606, 368.8713, 433.4212]
    
    phi2dfile[0,0] = datapath + 'euterpe/phi2d_helios_tj20_443.dat'
    phi2dfile[0,1] = datapath + 'euterpe/phi2d_helios_tj20_444.dat'
    phi2dfile[0,2] = datapath + 'euterpe/phi2d_helios_tj20_445.dat'
    phi2dfile[0,3] = datapath + 'euterpe/phi2d_helios_tj20_446.dat'
    phi2dfile[0,4] = datapath + 'euterpe/phi2d_helios_tj20_447.dat'
    phi2dfile[0,5] = datapath + 'euterpe/phi2d_helios_tj20_448.dat'
    
    phi2dfile[1,0] = datapath + 'euterpe/phi2d_helios_tj20_467.dat'
    phi2dfile[1,1] = datapath + 'euterpe/phi2d_helios_tj20_468.dat'
    phi2dfile[1,2] = datapath + 'euterpe/phi2d_helios_tj20_469.dat'
    phi2dfile[1,3] = datapath + 'euterpe/phi2d_helios_tj20_470.dat'
    phi2dfile[1,4] = datapath + 'euterpe/phi2d_helios_tj20_471.dat'
    phi2dfile[1,5] = datapath + 'euterpe/phi2d_helios_tj20_472.dat'


    chi = getphi2d(phi2dfile[0,0], out='chi')
    phi = getphi2d(phi2dfile[0,0], out='phi')
    
    for i in range(0,shape(phi2dfile)[0]):
        for j in range (0,shape(phi2dfile)[1]):
            print i, j
    
            phi2d[i,j,:,:]=getphi2d(phi2dfile[i,j])*phistar[i,j]


    phi1min = amin(phi2d[:,:,:,:])
    phi1max = amax(phi2d[:,:,:,:])


    fig = plt.figure(figsize = (18.0,11.0))
    ax1 = fig.add_subplot(231)
    ax2 = fig.add_subplot(232)
    ax3 = fig.add_subplot(233)
    ax4 = fig.add_subplot(234)
    ax5 = fig.add_subplot(235)
    ax6 = fig.add_subplot(236)

    #$\ E_{r}=-3.6 \ \\mathrm{kV m}^{-1}$

    im1 = ax1.pcolor(phi, chi, phi2d[0,0,:,:],vmin=phi1min, vmax=phi1max, cmap='RdBu_r',\
                     label='$T_{e}=7.9\ \\mathrm{eV}$')
    ax1.axis([0, phi[size(phi)-1], 0, chi[size(chi)-1]])
    ax1.set_xticks([])
    ax1.set_ylabel('$\\theta\ (\\mathrm{rad})$', fontsize=30)
#    ax1.set_title('$T_{e}=7.9\ \\mathrm{eV}$', fontsize=30)
    ax1.plot(probeB[0], probeB[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='B')
    ax1.plot(probeD[0], probeD[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='D')
    ax1.text(-0.3, 6.65, '$\ E_{r}=-3.6 \ \\mathrm{kV m}^{-1}$', fontsize=25,\
             bbox={'facecolor':'white', 'alpha':0.5, 'pad':5})
    ax1.text(0.05, 0.2, '$T_{e}=7.9\ \\mathrm{eV}$', fontsize=25)
             
    im2 = ax2.pcolor(phi, chi, phi2d[0,3,:,:],vmin=phi1min, vmax=phi1max, cmap='RdBu_r')
    ax2.axis([0, phi[size(phi)-1], 0, chi[size(chi)-1]])
    ax2.set_xticks([])
    ax2.set_yticks([])
#    ax2.set_title('$T_{e}=24.0\ \\mathrm{eV}$', fontsize=30)
    ax2.plot(probeB[0], probeB[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='B')
    ax2.plot(probeD[0], probeD[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='D')
    ax2.text(0.05, 0.2, '$T_{e}=24.0\ \\mathrm{eV}$', fontsize=25)
    
    im3 = ax3.pcolor(phi, chi, phi2d[0,5,:,:],vmin=phi1min, vmax=phi1max, cmap='RdBu_r')    
    ax3.axis([0, phi[size(phi)-1], 0, chi[size(chi)-1]])
    ax3.set_xticks([])
    ax3.set_yticks([])
#    ax3.set_title('$T_{e}=45.6\ \\mathrm{eV}$', fontsize=30)
    ax3.plot(probeB[0], probeB[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='B')
    ax3.plot(probeD[0], probeD[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='D')
    ax3.text(0.05, 0.2, '$T_{e}=45.6\ \\mathrm{eV}$', fontsize=25)


    im4 = ax4.pcolor(phi, chi, phi2d[1,0,:,:],vmin=phi1min, vmax=phi1max, cmap='RdBu_r')
    ax4.axis([0, phi[size(phi)-1], 0, chi[size(chi)-1]])
    ax4.set_xticks([0,0.5,1.0,1.5])
    ax4.set_xlabel('$\\phi\ (\\mathrm{rad})$', fontsize=30)
    ax4.set_ylabel('$\\theta\ (\\mathrm{rad})$', fontsize=30)
#    ax4.set_title('$T_{e}=7.9\ \\mathrm{eV}\ E_{r}=-5.0 \ \\mathrm{kV m}^{-1}$', fontsize=19)
    ax4.plot(probeB[0], probeB[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='B')
    ax4.plot(probeD[0], probeD[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='D')
    ax4.text(0.05, 0.2, '$T_{e}=7.9\ \\mathrm{eV}$', fontsize=25)
    ax4.text(-0.3, 6.65, '$\ E_{r}=-5.0 \ \\mathrm{kV m}^{-1}$', fontsize=25,\
             bbox={'facecolor':'white', 'alpha':0.5, 'pad':5})
    
    im5 = ax5.pcolor(phi, chi, phi2d[1,3,:,:],vmin=phi1min, vmax=phi1max, cmap='RdBu_r')
    ax5.axis([0, phi[size(phi)-1], 0, chi[size(chi)-1]])
    ax5.set_xticks([0,0.5,1.0,1.5])
    ax5.set_yticks([])
    ax5.set_xlabel('$\\phi\ (\\mathrm{rad})$', fontsize=30)
#    ax5.set_title('$T_{e}=24.0\ \\mathrm{eV}\ E_{r}=-5.0 \ \\mathrm{kV m}^{-1}', fontsize=19)    
    ax5.plot(probeB[0], probeB[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='B')
    ax5.plot(probeD[0], probeD[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='D')
    ax5.text(0.05, 0.2, '$T_{e}=24.0\ \\mathrm{eV}$', fontsize=25)
    
    im6 = ax6.pcolor(phi, chi, phi2d[1,5,:,:],vmin=phi1min, vmax=phi1max, cmap='RdBu_r')    
    ax6.axis([0, phi[size(phi)-1], 0, chi[size(chi)-1]])
    ax6.set_xticks([0,0.5,1.0,1.5])
    ax6.set_yticks([])
    ax6.set_xlabel('$\\phi\ (\\mathrm{rad})$', fontsize=30)
#    ax6.set_title('$T_{e}=45.6\ \\mathrm{eV}$', fontsize=19)
    ax6.plot(probeB[0], probeB[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='B')
    ax6.plot(probeD[0], probeD[1], marker='o',mfc = 'white', markeredgewidth=1.5, mec='black',\
             label='D')
    ax6.text(0.05, 0.2, '$T_{e}=45.6\ \\mathrm{eV}$', fontsize=25)
    ax3.text(1.5, 6.5, '${\Phi}_1$ (V)', fontsize=30)
    cax = fig.add_axes([0.91, 0.1, 0.03, 0.8])
    
    cbar = plt.colorbar(im6, cax=cax)
#    cbar.set_label('${\Phi}_1$ (V)', fontsize=30)
        
    plt.show()
    

##    fig, axes = plt.subplots(nrows=2, ncols=3)

##    for i in range(0,2):
##        for j in range(0,3):
##            axes[i, j].pcolor(phi, chi, phi2d[i,j,:,:]
##            axes[i, j].axis([0, phi[size(phi)-1], 0, chi[size(chi)-1]])
##            axes[i, j].set_xticks([])
##            axes[i, j].set_yticks([])
            
##    axes[0,0].set_yticks([1,2,3,4,5,6])
##    axes[1,0].set_yticks([1,2,3,4,5,6])
##    axes[1,0].set_xticks([0,0.5,1.0,1.5])
##    axes[1,1].set_xticks([0,0.5,1.0,1.5])
##    axes[1,2].set_xticks([0,0.5,1.0,1.5])
    
##    axes[0,0].set_ylabel('$\\theta\ [\\mathrm{rad}]$')
##    axes[1,0].set_ylabel('$\\theta\ [\\mathrm{rad}]$')
##    axes[1,0].set_xlabel('$\phi\ [\\mathrm{rad}]$')
##    axes[1,1].set_xlabel('$\phi\ [\\mathrm{rad}]$')
##    axes[1,2].set_xlabel('$\phi\ [\\mathrm{rad}]$')

##    colorbar
    
    
##    cbar=colorbar(axes[1,2])
    
    
    plt.show()



    # Figure with the potential difference between B and D

    fig = figure(num=None, figsize = (8.0,8.0), dpi = 100)
    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
                    wspace=0.00, hspace=0.00)
    plot           = plt.subplot(1,1,1)
    plot.grid(color='grey', linestyle='-', linewidth=0.3)
    plot.plot(te0,dphi1BD0, '-', color='black', marker='o',\
              label='$E_r=-3.6 \ \\mathrm{kV m}^{-1}$', linewidth=3,\
              markersize=7, mfc = 'white', markeredgewidth=2.5, mec='black')
    plot.plot(te1,dphi1BD1, '-', color='darkred',marker='s',\
              label='$E_r=-5.0 \ \\mathrm{kV m}^{-1}$', linewidth=3,\
              markersize=7, mfc = 'white', markeredgewidth=2.5, mec='darkred')
    plot.fill_between(te0, dphi1BD0, dphi1BD1, facecolor='grey', alpha=0.5)        
    plot.legend(loc=4,labelspacing=0.0, fontsize=20)
    plot.set_xlim([0,60])
    plot.set_ylim([0,8])
    plot.set_xlabel('$T_{e}\ (\\mathrm{eV})$', fontsize=30)
    plot.set_ylabel('$\Delta\Phi_1^{\\mathrm{BD}}\ (\\mathrm{V})$', fontsize=30)
    fig.show()

def doppler(phiang=67.1, shot='none'):

    path_data = '/home/jose/Results/2017_tj20_Doppler_assymetries/2017_spring_campaign/phi1_analisys/data/'
    path_data = '/home/jose/Computing/lab_python/euterpy/data/'


    if shot == 43387:
        files=['phi2d_marconi_tj20_0001.dat', 'phi2d_marconi_tj20_0002.dat',\
               'phi2d_marconi_tj20_0003.dat', 'phi2d_marconi_tj20_0004.dat',\
               'phi2d_marconi_tj20_0005.dat', 'phi2d_marconi_tj20_0006.dat',\
               'phi2d_marconi_tj20_0007.dat']
        
        cases=['marconi/tj20_0001', 'marconi/tj20_0002', 'marconi/tj20_0003',\
               'marconi/tj20_0004', 'marconi/tj20_0005', 'marconi/tj20_0006',\
               'marconi/tj20_0007']
    elif shot == 43391:
        files=['phi2d_marconi_tj20_0011.dat', 'phi2d_marconi_tj20_0012.dat',\
               'phi2d_marconi_tj20_0013.dat', 'phi2d_marconi_tj20_0014.dat',\
               'phi2d_marconi_tj20_0015.dat', 'phi2d_marconi_tj20_0016.dat',\
               'phi2d_marconi_tj20_0017.dat']
        
        cases=['marconi/tj20_0011', 'marconi/tj20_0012', 'marconi/tj20_0013',\
               'marconi/tj20_0014', 'marconi/tj20_0015', 'marconi/tj20_0016',\
               'marconi/tj20_0017']        
   
    datafiles = [path_data + x for x in files]

    chivec   = getphi2d(file=datafiles[0], out='chi')
    phivec   = getphi2d(file=datafiles[0], out='phi')
    
    R    = empty((size(files), size(chivec), size(phivec)), dtype='float')
    Z    = empty((size(files), size(chivec), size(phivec)), dtype='float')
    X    = empty((size(files), size(chivec), size(phivec)), dtype='float')
    Y    = empty((size(files), size(chivec), size(phivec)), dtype='float')
    Z    = empty((size(files), size(chivec), size(phivec)), dtype='float')    
    phi1 = empty((size(files), size(chivec), size(phivec)), dtype='float')

    Xall    = empty((size(files)*size(chivec), size(phivec)), dtype='float')
    Yall    = empty((size(files)*size(chivec), size(phivec)), dtype='float')
    Zall    = empty((size(files)*size(chivec), size(phivec)), dtype='float')  
    phi1all = empty((size(files)*size(chivec), size(phivec)), dtype='float')
    
    # We assume that the same R and Z meshes are used for all cases
    # Note: that flsurf provide the matrices in transposed order respect
    # to how phi2d.dat is read, and non-periodic.
    # Note: that R is already the polar R not rcyl.
    #


    
    for i in cases:
        n0 =  cases.index(i)      * size(chivec)
        nf = (cases.index(i) + 1) * size(chivec)
        
        R[cases.index(i),:,:]     = per(flsurf(i, out='R')).transpose()
        Z[cases.index(i),:,:]     = per(flsurf(i, out='Z')).transpose()
        phi1[cases.index(i),:,:]  = getphi2d(file=datafiles[cases.index(i)])

        Xall[n0:nf,:]     = R[cases.index(i),:,:]
        Yall[n0:nf,:]     = R[cases.index(i),:,:]
        Zall[n0:nf,:]     = Z[cases.index(i),:,:]
        phi1all[n0:nf,:]  = phi1[cases.index(i),:,:]

        print 'Phi1 data from file: ', datafiles[cases.index(i)], ' stored.'

    print 'Converting to Cartesian coordinates ...'
    for i in arange(0, size(phivec)):
        Xall[:,i] = Xall[:,i] * cos(phivec[i])
        Yall[:,i] = Yall[:,i] * sin(phivec[i])


    philoc  = 2*pi*67.1/360./(phivec[1]-phivec[0])
    
#    plt.axis('equal')
#    plt.scatter(Xall[:,philoc], Zall[:,philoc])
#    show()
    
    lowBR       = read_vmec0000('tj20', nsel_old_equil=0)[0]
    highBR      = read_vmec0000('tj20', nsel_old_equil=0)[1]
    lowBZ       = read_vmec0000('tj20', nsel_old_equil=0)[2]
    highBZ      = read_vmec0000('tj20', nsel_old_equil=0)[3]
    lowBX       = 0.2
    highBX      = 0.8
    
    nx, nz      = 20, 20
    ny          = nx
    
    xDR         = linspace(lowBX, highBX, nx)
    zDR         = linspace(0, 0.8, nz)
    yDR         = doppler_pl(xDR)

    xv, zv = meshgrid(xDR, zDR)

    phi1DR      = zeros([nx,nz])

    tol = 0.01
    
    for ichi in arange(0,size(files)*size(chivec)):
        for iphi in arange(0,size(phivec)):

            p2dgrid  = [Xall[ichi, iphi], Yall[ichi, iphi]]
            p2dplane = [Xall[ichi, iphi], doppler_pl(Xall[ichi, iphi])]

            if d2dcart(p2dgrid, p2dplane) < tol:

                vec_dx = abs(xDR-Xall[ichi, iphi])
                vec_dy = abs(yDR-Yall[ichi, iphi])
                vec_dz = abs(zDR-Zall[ichi, iphi])

                
                
                loc_x  = argmin(vec_dx)
                loc_y  = argmin(vec_dy)
                loc_z  = argmin(vec_dz)
                
                phi1DR[loc_x, loc_z] = phi1all[ichi, iphi]


    fig= plt.figure()
    ax= fig.add_subplot(111, projection= '3d')
    ax.scatter(Xall[:,philoc],Yall[:,philoc],Zall[:,philoc])
    ax.scatter(xv,doppler_pl(xv), zv)    
    ax.set_xlabel('X axis')
    ax.set_ylabel('Y axis')
    ax.set_zlabel('Z axis')

##    fig2= plt.figure()
##    ax2= fig.add_subplot(111)
##    plt.pcolor(xDR,zDR, phi1DR.transpose())
##    ax2.set_xlabel('X axis')
##    ax2.set_ylabel('Y axis')



    show()
    
     
    
##    for i in arange(0, nx):
##        print 'Running DR plane at ix = ', i
##        for j in arange(0, ny):
##            # If xDR, 


##            for k in arange(0, nz):


                  

##                if d2dcart()
                
##                for ichi in arange(0,size(files)*size(chivec)):
##                    for iphi in arange(0,size(phivec)):
                        
##                        pplane = [xDR[i], yDR[j], zDR[k]]
##                        pgrid  = [Xall[ichi, iphi], Yall[ichi, iphi], Zall[ichi, iphi]]
                        
##                        if d3dcart(pplane, pgrid) < 0.01:
##                            phi1DR[i,j,k] = phi1all[ichi, iphi]
                

    
##def doppler_pl(x):

##    phi0_d    = 67.1                 # angle in deg.
##    phi0_r    = phi0_d*2*pi/360.     # Toroidal angle in rad.
##    alph_d    = 26.0                 # Angle between DR plane and toroidal plane in deg.    
##    alph_r    = alph_d*2*pi/360.     # Angle between DR plane and toroidal plane in rad.
##    Xhc       = 1.5 * cos(phi0_r)    # X coord. of the hardcore
##    Yhc       = 1.5 * sin(phi0_r)    # X coord. of the hardcore
##    Zhc       = 0.0                  # Y coord. of the hardcore
##    Y0        = 1.5 * (sin(phi0_r)-tan(phi0_r-alph_r)*cos(phi0_r)) # DR plane cut at y-axis
##    m         = tan(phi0_r - alph_r) # DR plane slopt at x-y plane
##    return m*x + Y0


def d2dcart(p0=[0,0], p1=[0,0]):
    
    return sqrt((p1[0]-p0[0])**2. + (p1[1]-p0[1])**2.)


def d3dcart(p0=[0,0,0], p1=[0,0,0]):
    
    return sqrt((p1[0]-p0[0])**2. + (p1[1]-p0[1])**2. + (p1[2]-p0[2])**2.)


##    R_all    = empty(size(chivec)*size(files), dtype='float')
##    Z_all    = empty(size(chivec)*size(files), dtype='float')
##    phi1_all = empty(size(chivec)*size(files), dtype='float')
    
##    for i in cases:
##        n0 =  cases.index(i)      * size(chivec)
##        nf = (cases.index(i) + 1) * size(chivec)
        
##        phi1[cases.index(i),:,:]  = getphi2d(file=datafiles[cases.index(i)])
##        R[cases.index(i),:,:]     = per(flsurf(i, out='R')).transpose()
##        Z[cases.index(i),:,:]     = per(flsurf(i, out='Z')).transpose()
        
##        R_all[n0:nf]    = R[cases.index(i),:,loc_phi]
##        Z_all[n0:nf]    = Z[cases.index(i),:,loc_phi]
##        phi1_all[n0:nf] = phi1[cases.index(i),:,loc_phi]



###    ne      = interpolate.splev(s,tck_ne,der=0)




##    nR, nZ = 200, 200
##    Rmax   =  max(R_all)
##    Rmin   =  min(R_all)
##    Zmax   =  max(Z_all)
##    Zmin   =  min(Z_all)
##    delR   = (Rmax-Rmin)/nR
##    delZ   = (Zmax-Zmin)/nZ
    
##    Rnew   = linspace(Rmin, Rmax, nR)
##    Znew   = linspace(Zmin, Zmax, nZ)
##    Rnew, Znew = np.meshgrid(Rnew, Znew)

###    x, y, z = R_all.values, Z_all.values, phi1_all.values
##    phi1new  = griddata((R_all, Z_all), phi1_all, (Rnew, Znew))


##    figure1 = figure(num=None, figsize=(7.0,6.0), dpi=100)
##    subplots_adjust(left=0.2, bottom=0.2, right=0.9, top=0.9,\
##                    wspace=0.00, hspace=0.00)
##    plot1          = plt.subplot(1,1,1)
##    plot1.set_ylabel('$Z$ [rad] ')
##    plot1.set_xlabel('$R$ [rad]')
##    plot1.axis('equal')
##    plot1.set_xticks([1.2,1.4,1.6,1.8])
##    plot1.set_yticks([0.2,0.4,0.6,0.8])
##    cax            = plot1.scatter(R_all, Z_all, c=phi1_all, s=200, edgecolor='none')
##    cbar           = colorbar(cax)
##    cbar.set_label('${\Phi}_1$ [V]')
##    plot1.yaxis.set_minor_locator(AutoMinorLocator(10))
##    plot1.xaxis.set_minor_locator(AutoMinorLocator(10))
##    plot1.grid(color='grey', linestyle='-', linewidth=0.3)

##    figure1.tight_layout(pad=0.15, h_pad=0, w_pad=0)
##    savefig('/home/jose/Escritorio/phi1_DR_test_shot' + str(shot) + '.eps', dpi=50)

##    plt.show()
    
###    z_new=interp2d(R_all, Z_all, phi1_all, kind='linear', bounds_error=False, fill_value=nan)

###    plt.pcolor(grid_x[:,0], grid_y[0,:], znew)


###    plt.pcolor(Rnew, Znew,phi1new, edgecolors='', s=100)
###    plt.colorbar()
###    plt.axis('equal')
###    plt.show()
    
def per(matrix='none'):

    #   (nrows, ncols)
    a    = matrix
    a    = c_[a, a[:,0]]
    a    = r_[a, [a[0,:]]]
    return a


def eusfincs():

    # Values of parameters and their gradients at the benchmark radius.
    rho_b     = 0.5
    s_b       = rho_b**2.0
    drhods_b  = 1./(2*rho_b)

    dtidrho_b = -2.12 #keV
    ti_b      = 3.77  #keV
    dtids_b   = dtidrho_b * drhods_b
    dlntids_b = dtids_b / ti_b
    ti1       = dlntids_b/(dlntids_b * s_b - 1)
    ti0       = ti_b / (1 - ti1*s_b)

    dtedrho_b = -4.31 #keV
    te_b      = 4.13  #keV
    dteds_b   = dtedrho_b * drhods_b
    dlnteds_b = dteds_b / te_b
    te1       = dlnteds_b/(dlnteds_b * s_b - 1)
    te0       = te_b / (1 - te1*s_b)
    
    lx, dtidt0 = lx_t0(equil='w7xr03', profile_type=2, species='i',\
                       t0=ti0, t1=ti1, t2=1.0, t3=1.0,\
                       te0=te0, te1=te1, te2=1.0, te3=1.0, lx=0.0,nsel_old_equil=1)


##    ne_b       = array([9.258931e+17, 1.646500e+18, 2.927900e+18, 5.206700e+18,\
##                        9.258931e+18, 1.646500e+19, 2.927900e+19, 5.206700e+19,\
##                        9.258931e+19, 1.646500e+20, 2.927900e+20, 5.206700e+20,\
##                        9.258900e+20, 1.646500e+21, 2.927900e+21, 5.206700e+21,\
##                        9.258900e+21, 1.646500e+22, 2.927900e+22, 5.206700e+22,\
##                        9.258900e+22, 1.646500e+23, 2.927900e+23, 5.206700e+23,\
##                        9.258900e+23, 1.646500e+24, 2.927900e+24, 5.206700e+24,\
##                        9.258900e+24, 1.646500e+25, 2.927900e+25, 5.206700e+25,\
##                        9.258900e+25, 1.646500e+26, 2.927900e+26, 5.206700e+26\])
    ne_b       = array([9.258931e+17,\
                        9.258931e+18,\
                        9.258931e+19,\
                        9.258900e+20,\
                        9.258900e+21,\
                        9.258900e+22,\
                        9.258900e+23,\
                        9.258900e+24,\
                        9.258900e+25,\
                        9.258900e+26])
    
#    ne_b       = 9.258931e+22

    dlnedrho_b = -0.33E20 / 0.92589E20 # Same for all ne_b
    dlneds_b   = dlnedrho_b * drhods_b

    ne1        = dlneds_b / (s_b * dlneds_b  - 1)
    ne0        = ne_b / (1. - ne1 * s_b)

    print 'ti0 = ', ti0
    print 'ti1 = ', ti1
    print 'ti2 = ', 1.0
    print 'ti3 = ', 1.0
    print '  '
    print 'te0 = ', te0
    print 'te1 = ', te1
    print 'te2 = ', 1.0
    print 'te3 = ', 1.0
    print ''
    print 'lx, dtsdte(s_norm) = ', lx, dtidt0
    print ''
    print 'ne0 = ', ne0
    print 'ne1 = ', ne1
    print 'ne2 = ', 1.0
    print 'ne3 = ', 1.0      

def make_per_2d(matin):
    # Remember: a vertor such that e.g. shape(v)=64
    # means that its last component is v[63].
    nx                     = shape(matin)[0]
    ny                     = shape(matin)[1]
    matout                 = zeros([nx+1,ny+1])
    matout[0:nx, 0:ny]     = matin
    matout[0:nx,   ny]     = matin[:,0]
    matout[nx  , 0:ny]     = matin[0,:]
    matout[nx    , ny]     = matin[0,0]
#    print matin
    return matout


def test(nx=10, ny=20):

    mat = zeros([nx, ny])
    print shape(mat)
    
#    for ix in arange(0,nx):
#        for iy in arange(0,ny):
            

    
